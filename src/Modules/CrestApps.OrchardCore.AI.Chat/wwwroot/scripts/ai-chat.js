/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
window.openAIChatManager = function () {
  // Defaults (can be overridden by instanceConfig)
  var defaultConfig = {
    // UI defaults for generated media
    generatedImageAltText: 'Generated Image',
    generatedImageMaxWidth: 400,
    generatedChartMaxWidth: 900,
    downloadImageTitle: 'Download image',
    downloadChartTitle: 'Download chart as image',
    downloadChartButtonText: 'Download',
    messageTemplate: "\n        <div class=\"list-group\">\n            <div v-for=\"(message, index) in messages\" :key=\"index\" class=\"list-group-item\">\n                <div class=\"d-flex align-items-center\">\n                    <div class=\"p-2\">\n                        <i :class=\"message.role === 'user' ? 'fa-solid fa-user fa-2xl text-primary' : 'fa fa-robot fa-2xl' + (message.isStreaming ? ' ai-streaming-icon' : ' ai-bot-icon')\"></i>\n                    </div>\n                    <div class=\"p-2 lh-base\">\n                        <h4 v-if=\"message.title\">{{ message.title }}</h4>\n                        <div v-html=\"message.htmlContent || message.content\"></div>\n                    </div>\n                </div>\n                <div class=\"d-flex justify-content-center message-buttons-container\" v-if=\"!isIndicator(message)\">\n                    <button class=\"ms-2 btn btn-sm btn-outline-secondary button-message-toolbox\" @click=\"copyResponse(message.content)\" title=\"Click here to copy response to clipboard.\">\n                        <i class=\"fa-solid fa-copy fa-lg\"></i>\n                    </button>\n                </div>\n            </div>\n        </div>\n    ",
    indicatorTemplate: "<div class=\"spinner-grow spinner-grow-sm\" role=\"status\"><span class=\"visually-hidden\">Loading...</span></div>"
  };
  var renderer = new marked.Renderer();

  // Modify the link rendering to open in a new tab
  renderer.link = function (data) {
    return "<a href=\"".concat(data.href, "\" target=\"_blank\" rel=\"noopener noreferrer\">").concat(data.text, "</a>");
  };

  // Custom image renderer for generated images with thumbnail styling and download button.
  // Handles both URL and data-URI sources (data URIs are converted to blobs for download).
  renderer.image = function (data) {
    var src = data.href;
    var alt = data.text || defaultConfig.generatedImageAltText;
    var maxWidth = defaultConfig.generatedImageMaxWidth;
    return "<div class=\"generated-image-container\">\n        <img src=\"".concat(src, "\" alt=\"").concat(alt, "\" class=\"img-thumbnail\" style=\"max-width: ").concat(maxWidth, "px; height: auto;\" />\n        <div class=\"mt-2\">\n            <a href=\"").concat(src, "\" target=\"_blank\" download=\"").concat(alt, "\" title=\"").concat(defaultConfig.downloadImageTitle, "\" class=\"btn btn-sm btn-outline-secondary ai-download-image\">\n                <i class=\"fa-solid fa-download\"></i>\n            </a>\n        </div>\n    </div>");
  };

  // Chart counter for unique IDs
  var chartCounter = 0;

  // Collector for charts discovered during marked parsing.
  var _pendingCharts = [];
  function createChartHtml(chartId) {
    var chartMaxWidth = defaultConfig.generatedChartMaxWidth;
    return "<div class=\"chart-container\" style=\"position: relative; width: 100%; max-width: ".concat(chartMaxWidth, "px; margin: 0 auto; height: 480px;\">") + "<canvas id=\"".concat(chartId, "\" class=\"img-thumbnail\" width=\"").concat(chartMaxWidth, "\" height=\"480\" style=\"width: 100%; height: 480px;\"></canvas>") + "</div>" + "<div class=\"mt-2\">" + "<button type=\"button\" class=\"btn btn-sm btn-outline-secondary\" onclick=\"downloadChart('".concat(chartId, "')\" title=\"").concat(defaultConfig.downloadChartTitle, "\">") + "<i class=\"fa-solid fa-download\"></i> ".concat(defaultConfig.downloadChartButtonText) + "</button>" + "</div>";
  }

  // Register [chart:{...json...}] as a native marked block extension so the
  // markdown parser handles chart markers inline with surrounding text.
  marked.use({
    extensions: [{
      name: 'chart',
      level: 'block',
      start: function start(src) {
        var idx = src.indexOf('[chart:');
        return idx >= 0 ? idx : undefined;
      },
      tokenizer: function tokenizer(src) {
        var extracted = tryExtractChartMarker(src);
        if (!extracted || extracted.startIndex !== 0) {
          return undefined;
        }
        var chartId = "chat_chart_".concat(++chartCounter);
        return {
          type: 'chart',
          raw: src.substring(0, extracted.endIndex),
          chartId: chartId,
          json: extracted.json
        };
      },
      renderer: function renderer(token) {
        _pendingCharts.push({
          chartId: token.chartId,
          config: token.json
        });
        return createChartHtml(token.chartId);
      }
    }]
  });

  // Extract a [chart:{...json...}] marker. This avoids regex issues with nested brackets.
  function tryExtractChartMarker(text) {
    var token = '[chart:';
    var start = text.indexOf(token);
    if (start < 0) {
      return null;
    }

    // Find JSON object boundary by balancing braces
    var jsonStart = start + token.length;
    var i = jsonStart;
    while (i < text.length && (text[i] === ' ' || text[i] === '\n' || text[i] === '\r' || text[i] === '\t')) {
      i++;
    }
    if (i >= text.length || text[i] !== '{') {
      return null;
    }
    var depth = 0;
    var inString = false;
    var escape = false;
    for (; i < text.length; i++) {
      var ch = text[i];
      if (inString) {
        if (escape) {
          escape = false;
          continue;
        }
        if (ch === '\\') {
          escape = true;
          continue;
        }
        if (ch === '"') {
          inString = false;
        }
        continue;
      }
      if (ch === '"') {
        inString = true;
        continue;
      }
      if (ch === '{') {
        depth++;
      } else if (ch === '}') {
        depth--;
        if (depth === 0) {
          var jsonEnd = i;
          // Expect closing bracket after JSON
          var closeBracketIndex = text.indexOf(']', jsonEnd + 1);
          if (closeBracketIndex < 0) {
            return null;
          }
          var json = text.substring(jsonStart, jsonEnd + 1).trim();
          return {
            startIndex: start,
            endIndex: closeBracketIndex + 1,
            json: json
          };
        }
      }
    }
    return null;
  }
  function renderChartsInMessage(message) {
    if (!message || !message._pendingCharts || !message._pendingCharts.length) {
      return;
    }
    var _iterator = _createForOfIteratorHelper(message._pendingCharts),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var c = _step.value;
        var canvas = document.getElementById(c.chartId);
        if (!canvas) {
          continue;
        }
        if (typeof Chart === 'undefined') {
          console.error('Chart.js is not available on the page.');
          continue;
        }
        try {
          var _cfg$options;
          // Destroy existing chart instance if re-rendering
          if (canvas._chartInstance) {
            canvas._chartInstance.destroy();
          }
          var cfg = typeof c.config === 'string' ? JSON.parse(c.config) : c.config;
          (_cfg$options = cfg.options) !== null && _cfg$options !== void 0 ? _cfg$options : cfg.options = {};
          cfg.options.responsive = true;
          cfg.options.maintainAspectRatio = false;
          canvas._chartInstance = new Chart(canvas, cfg);
        } catch (e) {
          console.error('Error creating chart:', e);
        }
      }

      // Prevent re-render work
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    message._pendingCharts = [];
  }

  // Parse markdown content via marked (which natively handles [chart:...] markers
  // through the registered extension) and collect pending chart configs for later
  // Chart.js rendering.
  function parseMarkdownContent(content, message) {
    _pendingCharts = [];
    var html = marked.parse(content, {
      renderer: renderer
    });
    message._pendingCharts = _pendingCharts.length > 0 ? _toConsumableArray(_pendingCharts) : [];
    return html;
  }
  var initialize = function initialize(instanceConfig) {
    var config = Object.assign({}, defaultConfig, instanceConfig);
    // Keep defaultConfig in sync so renderers use overridden values
    defaultConfig = config;
    if (!config.signalRHubUrl) {
      console.error('The signalRHubUrl is required.');
      return;
    }
    if (!config.appElementSelector) {
      console.error('The appElementSelector is required.');
      return;
    }
    if (!config.chatContainerElementSelector) {
      console.error('The chatContainerElementSelector is required.');
      return;
    }
    if (!config.inputElementSelector) {
      console.error('The inputElementSelector is required.');
      return;
    }
    if (!config.sendButtonElementSelector) {
      console.error('The sendButtonElementSelector is required.');
      return;
    }
    var app = Vue.createApp({
      data: function data() {
        return {
          inputElement: null,
          buttonElement: null,
          chatContainer: null,
          placeholder: null,
          isSessionStarted: false,
          isPlaceholderVisible: true,
          chatWidgetStateName: null,
          chatWidgetStateSession: null,
          chatHistorySection: null,
          widgetIsInitialized: false,
          isSteaming: false,
          isNavigatingAway: false,
          autoScroll: true,
          stream: null,
          messages: [],
          prompt: ''
        };
      },
      methods: {
        handleBeforeUnload: function handleBeforeUnload() {
          this.isNavigatingAway = true;
        },
        startConnection: function startConnection() {
          var _this = this;
          return _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
            var _t;
            return _regenerator().w(function (_context) {
              while (1) switch (_context.p = _context.n) {
                case 0:
                  _this.connection = new signalR.HubConnectionBuilder().withUrl(config.signalRHubUrl).withAutomaticReconnect().build();

                  // Allow long-running operations (e.g., multi-step MCP tool calls)
                  // without the client disconnecting prematurely.
                  _this.connection.serverTimeoutInMilliseconds = 600000;
                  _this.connection.keepAliveIntervalInMilliseconds = 15000;
                  _this.connection.on("LoadSession", function (data) {
                    var _data$messages;
                    _this.initializeSession(data.sessionId, true);
                    _this.messages = [];
                    ((_data$messages = data.messages) !== null && _data$messages !== void 0 ? _data$messages : []).forEach(function (msg) {
                      _this.addMessage(msg);
                      _this.$nextTick(function () {
                        renderChartsInMessage(msg);
                      });
                    });
                  });
                  _this.connection.on("ReceiveError", function (error) {
                    console.error("SignalR Error: ", error);
                  });
                  _this.connection.onreconnecting(function () {
                    console.warn("SignalR: reconnecting...");
                  });
                  _this.connection.onreconnected(function () {
                    console.info("SignalR: reconnected.");
                  });
                  _this.connection.onclose(function (error) {
                    if (_this.isNavigatingAway) {
                      return;
                    }
                    if (error) {
                      console.warn("SignalR connection closed with error:", error.message || error);
                    }
                  });
                  _context.p = 1;
                  _context.n = 2;
                  return _this.connection.start();
                case 2:
                  _context.n = 4;
                  break;
                case 3:
                  _context.p = 3;
                  _t = _context.v;
                  console.error("SignalR Connection Error: ", _t);
                case 4:
                  return _context.a(2);
              }
            }, _callee, null, [[1, 3]]);
          }))();
        },
        addMessageInternal: function addMessageInternal(message) {
          var _this2 = this;
          this.fireEvent(new CustomEvent("addingOpenAIPromotMessage", {
            detail: {
              message: message
            }
          }));
          this.messages.push(message);
          this.$nextTick(function () {
            _this2.fireEvent(new CustomEvent("addedOpenAIPromotMessage", {
              detail: {
                message: message
              }
            }));
          });
        },
        addMessage: function addMessage(message) {
          var _this3 = this;
          if (message.content) {
            var processedContent = message.content.trim();
            if (message.references && _typeof(message.references) === "object" && Object.keys(message.references).length) {
              for (var _i = 0, _Object$entries = Object.entries(message.references); _i < _Object$entries.length; _i++) {
                var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                  key = _Object$entries$_i[0],
                  value = _Object$entries$_i[1];
                processedContent = processedContent.replaceAll(key, "<sup><strong>".concat(value.index, "</strong></sup>"));
              }

              // if we have multiple references, add a comma to ensure we don't concatenate numbers.
              processedContent = processedContent.replaceAll('</strong></sup><sup>', '</strong></sup><sup>,</sup><sup>');
              processedContent += '<br><br>';
              for (var _i2 = 0, _Object$entries2 = Object.entries(message.references); _i2 < _Object$entries2.length; _i2++) {
                var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
                  _key = _Object$entries2$_i[0],
                  _value = _Object$entries2$_i[1];
                processedContent += "**".concat(_value.index, "**. [").concat(_value.text, "](").concat(_value.link, ")<br>");
              }
            }
            message.content = processedContent;
            message.htmlContent = parseMarkdownContent(processedContent, message);
          }
          this.addMessageInternal(message);
          this.hidePlaceholder();
          this.$nextTick(function () {
            // Render any pending charts once the DOM is updated
            renderChartsInMessage(message);
            _this3.scrollToBottom();
          });
        },
        addMessages: function addMessages(messages) {
          var _this4 = this;
          for (var i = 0; i < messages.length; i++) {
            this.addMessageInternal(messages[i]);
          }
          this.hidePlaceholder();
          this.$nextTick(function () {
            _this4.scrollToBottom();
          });
        },
        hidePlaceholder: function hidePlaceholder() {
          if (this.placeholder) {
            this.placeholder.classList.add('d-none');
          }
          this.isPlaceholderVisible = false;
        },
        showPlaceholder: function showPlaceholder() {
          if (this.placeholder) {
            this.placeholder.classList.remove('d-none');
          }
          this.isPlaceholderVisible = true;
        },
        fireEvent: function fireEvent(event) {
          document.dispatchEvent(event);
        },
        isIndicator: function isIndicator(message) {
          return message.role === 'indicator';
        },
        sendMessage: function sendMessage() {
          var trimmedPrompt = this.prompt.trim();
          if (!trimmedPrompt) {
            return;
          }
          this.addMessage({
            role: 'user',
            content: trimmedPrompt
          });
          this.streamMessage(this.getProfileId(), trimmedPrompt, null);
          this.inputElement.value = '';
          this.prompt = '';
        },
        streamMessage: function streamMessage(profileId, trimmedPrompt, sessionProfileId) {
          var _this5 = this;
          if (this.stream) {
            this.stream.dispose();
            this.stream = null;
          }
          this.streamingStarted();
          this.showTypingIndicator();
          this.autoScroll = true;
          var content = '';
          var references = {};

          // Get the index after showing typing indicator.
          var messageIndex = this.messages.length;
          var currentSessionId = this.getSessionId();
          this.stream = this.connection.stream("SendMessage", profileId, trimmedPrompt, currentSessionId, sessionProfileId).subscribe({
            next: function next(chunk) {
              var message = _this5.messages[messageIndex];
              if (!message) {
                if (chunk.sessionId && !currentSessionId) {
                  _this5.setSessionId(chunk.sessionId);
                }
                _this5.hideTypingIndicator();
                // Re-assign the index after hiding the typing indicator.
                messageIndex = _this5.messages.length;
                var newMessage = {
                  role: "assistant",
                  title: chunk.title,
                  content: "",
                  htmlContent: "",
                  isStreaming: true
                };
                _this5.messages.push(newMessage);
                message = newMessage;
              }
              if (chunk.title && (!message.title || message.title !== chunk.title)) {
                message.title = chunk.title;
              }
              if (chunk.references && _typeof(chunk.references) === "object" && Object.keys(chunk.references).length) {
                for (var _i3 = 0, _Object$entries3 = Object.entries(chunk.references); _i3 < _Object$entries3.length; _i3++) {
                  var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2),
                    key = _Object$entries3$_i[0],
                    value = _Object$entries3$_i[1];
                  references[key] = value;
                }
              }
              if (chunk.content) {
                var processedContent = chunk.content;
                for (var _i4 = 0, _Object$entries4 = Object.entries(references); _i4 < _Object$entries4.length; _i4++) {
                  var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i4], 2),
                    _key2 = _Object$entries4$_i[0],
                    _value2 = _Object$entries4$_i[1];
                  processedContent = processedContent.replaceAll(_key2, "<sup><strong>".concat(_value2.index, "</strong></sup>"));
                }

                // Append processed content to the message.
                // if we have multiple references, add a comma to ensure we don't concatenate numbers.
                content += processedContent.replaceAll('</strong></sup><sup>', '</strong></sup><sup>,</sup><sup>');
              }

              // Update the existing message
              message.content = content;
              message.htmlContent = parseMarkdownContent(content, message);
              _this5.messages[messageIndex] = message;
              _this5.$nextTick(function () {
                renderChartsInMessage(message);
                _this5.scrollToBottom();
              });
            },
            complete: function complete() {
              var _this5$stream;
              _this5.processReferences(references, messageIndex);
              _this5.streamingFinished();
              var msg = _this5.messages[messageIndex];
              if (msg) {
                msg.isStreaming = false;
              }
              if (!msg || !msg.content) {
                // No content received at all.
                _this5.hideTypingIndicator();
              }
              (_this5$stream = _this5.stream) === null || _this5$stream === void 0 || _this5$stream.dispose();
              _this5.stream = null;
            },
            error: function error(err) {
              var _this5$stream2;
              _this5.processReferences(references, messageIndex);
              _this5.streamingFinished();
              var msg = _this5.messages[messageIndex];
              if (msg) {
                msg.isStreaming = false;
              }
              _this5.hideTypingIndicator();
              if (!_this5.isNavigatingAway) {
                _this5.addMessage(_this5.getServiceDownMessage());
              }
              (_this5$stream2 = _this5.stream) === null || _this5$stream2 === void 0 || _this5$stream2.dispose();
              _this5.stream = null;
              console.error("Stream error:", err);
            }
          });
        },
        getServiceDownMessage: function getServiceDownMessage() {
          var newMessage = {
            role: "assistant",
            content: "Our service is currently unavailable. Please try again later. We apologize for the inconvenience.",
            htmlContent: ""
          };
          return newMessage;
        },
        processReferences: function processReferences(references, messageIndex) {
          if (Object.keys(references).length) {
            var _message$content;
            var message = this.messages[messageIndex];
            message.content = ((_message$content = message.content) === null || _message$content === void 0 ? void 0 : _message$content.trim()) + '<br><br>' || '';
            for (var _i5 = 0, _Object$entries5 = Object.entries(references); _i5 < _Object$entries5.length; _i5++) {
              var _Object$entries5$_i = _slicedToArray(_Object$entries5[_i5], 2),
                key = _Object$entries5$_i[0],
                value = _Object$entries5$_i[1];
              message.content += "**".concat(value.index, "**. [").concat(value.text, "](").concat(value.link, ")<br>");
            }
            message.htmlContent = parseMarkdownContent(message.content, message);
            this.messages[messageIndex] = message;
            this.scrollToBottom();
          }
        },
        streamingStarted: function streamingStarted() {
          var stopIcon = this.buttonElement.getAttribute('data-stop-icon');
          if (stopIcon) {
            this.buttonElement.innerHTML = stopIcon;
          }
        },
        streamingFinished: function streamingFinished() {
          var startIcon = this.buttonElement.getAttribute('data-start-icon');
          if (startIcon) {
            this.buttonElement.innerHTML = startIcon;
          }
        },
        generatePrompt: function generatePrompt(element) {
          if (!element) {
            console.error('The element paramter is required.');
            return;
          }
          var templateProfileId = element.getAttribute('data-profile-id');
          var sessionId = this.getSessionId();
          var sessionProfileId = this.getProfileId();
          if (!templateProfileId || !sessionId) {
            console.error('The given element is missing data-profile-id or the session has not yet started.');
            return;
          }

          // streamMessage() already shows the typing indicator.
          this.streamMessage(templateProfileId, null, sessionProfileId);
        },
        createSessionUrl: function createSessionUrl(baseUrl, param, value) {
          var fullUrl = baseUrl.toLowerCase().startsWith('http') ? baseUrl : window.location.origin + baseUrl;
          var url = new URL(fullUrl);
          url.searchParams.set(param, value);
          return url.toString();
        },
        showTypingIndicator: function showTypingIndicator() {
          this.addMessage({
            role: 'indicator',
            htmlContent: config.indicatorTemplate
          });
        },
        hideTypingIndicator: function hideTypingIndicator() {
          var originalLength = this.messages.length;
          this.messages = this.messages.filter(function (msg) {
            return msg.role !== 'indicator';
          });
          var removedCount = originalLength - this.messages.length;
          return removedCount;
        },
        scrollToBottom: function scrollToBottom() {
          var _this6 = this;
          if (!this.autoScroll) {
            return;
          }
          setTimeout(function () {
            _this6.chatContainer.scrollTop = _this6.chatContainer.scrollHeight - _this6.chatContainer.clientHeight;
          }, 50);
        },
        handleUserInput: function handleUserInput(event) {
          this.prompt = event.target.value;
        },
        getProfileId: function getProfileId() {
          return this.inputElement.getAttribute('data-profile-id');
        },
        setSessionId: function setSessionId(sessionId) {
          this.inputElement.setAttribute('data-session-id', sessionId || '');
        },
        resetSession: function resetSession() {
          this.setSessionId('');
          this.isSessionStarted = false;
          if (this.widgetIsInitialized) {
            localStorage.removeItem(this.chatWidgetStateSession);
          }
          this.messages = [];
          this.showPlaceholder();
        },
        initializeApp: function initializeApp() {
          var _this7 = this;
          this.inputElement = document.querySelector(config.inputElementSelector);
          this.buttonElement = document.querySelector(config.sendButtonElementSelector);
          this.chatContainer = document.querySelector(config.chatContainerElementSelector);
          this.placeholder = document.querySelector(config.placeholderElementSelector);

          // Pause auto-scroll when the user manually scrolls up during streaming.
          this.chatContainer.addEventListener('scroll', function () {
            if (!_this7.stream) {
              return;
            }
            var threshold = 30;
            var atBottom = _this7.chatContainer.scrollHeight - _this7.chatContainer.clientHeight - _this7.chatContainer.scrollTop <= threshold;
            _this7.autoScroll = atBottom;
          });
          this.inputElement.addEventListener('keyup', function (event) {
            if (_this7.stream != null) {
              return;
            }
            if (event.key === "Enter" && !event.shiftKey) {
              _this7.buttonElement.click();
            }
          });
          this.inputElement.addEventListener('input', function (e) {
            _this7.handleUserInput(e);
            if (e.target.value.trim()) {
              _this7.buttonElement.removeAttribute('disabled');
            } else {
              _this7.buttonElement.setAttribute('disabled', true);
            }
          });
          this.buttonElement.addEventListener('click', function () {
            if (_this7.stream != null) {
              _this7.stream.dispose();
              _this7.stream = null;
              _this7.streamingFinished();
              _this7.hideTypingIndicator();

              // Clean up: remove empty assistant message or stop streaming animation.
              if (_this7.messages.length > 0) {
                var lastMsg = _this7.messages[_this7.messages.length - 1];
                if (lastMsg.role === 'assistant' && !lastMsg.content) {
                  _this7.messages.pop();
                } else if (lastMsg.isStreaming) {
                  lastMsg.isStreaming = false;
                }
              }
              return;
            }
            _this7.sendMessage();
          });
          var promptGenerators = document.getElementsByClassName('profile-generated-prompt');
          for (var i = 0; i < promptGenerators.length; i++) {
            promptGenerators[i].addEventListener('click', function (e) {
              e.preventDefault();
              _this7.generatePrompt(e.target);
            });
          }
          var chatSessions = document.getElementsByClassName('chat-session-history-item');
          for (var i = 0; i < chatSessions.length; i++) {
            chatSessions[i].addEventListener('click', function (e) {
              e.preventDefault();
              var sessionId = e.target.getAttribute('data-session-id');
              if (!sessionId) {
                console.error('an element with the class chat-session-history-item with no data-session-id set.');
                return;
              }
              _this7.loadSession(sessionId);
              _this7.showChatScreen();
            });
          }
          for (var _i6 = 0; _i6 < config.messages.length; _i6++) {
            this.addMessage(config.messages[_i6]);
          }
        },
        loadSession: function loadSession(sessionId) {
          this.connection.invoke("LoadSession", sessionId)["catch"](function (err) {
            return console.error(err);
          });
        },
        reloadCurrentSession: function reloadCurrentSession() {
          var sessionId = this.getSessionId();
          if (sessionId) {
            this.loadSession(sessionId);
          }
        },
        initializeSession: function initializeSession(sessionId, force) {
          if (this.isSessionStarted && !force) {
            return;
          }
          this.fireEvent(new CustomEvent("initializingSessionOpenAIChat", {
            detail: {
              sessionId: sessionId
            }
          }));
          this.setSessionId(sessionId);
          this.isSessionStarted = true;
          if (this.widgetIsInitialized) {
            localStorage.setItem(this.chatWidgetStateSession, sessionId);
          }
        },
        initializeWidget: function initializeWidget() {
          var _this8 = this;
          if (!config.widget.showChatButton) {
            console.error('The widget showChatButton is required.');
            return;
          }
          if (!config.widget.chatWidgetContainer) {
            console.error('The widget chatWidgetContainer is required.');
            return;
          }
          if (!config.widget.chatWidgetStateName) {
            console.error('The widget chatWidgetStateName is required.');
            return;
          }
          var showChatButton = document.querySelector(config.widget.showChatButton);
          if (!showChatButton) {
            return;
          }
          var chatWidgetContainer = document.querySelector(config.widget.chatWidgetContainer);
          if (!chatWidgetContainer) {
            return;
          }
          if (config.widget.chatHistorySection) {
            this.chatHistorySection = document.querySelector(config.widget.chatHistorySection);
          }
          this.chatWidgetStateName = config.widget.chatWidgetStateName;
          this.chatWidgetStateSession = config.widget.chatWidgetStateName + 'Session';
          this.widgetIsInitialized = true;
          var isOpen = localStorage.getItem(this.chatWidgetStateName) === 'open';
          if (isOpen) {
            this.reloadCurrentSession();
            chatWidgetContainer.classList.remove('d-none');
          }
          showChatButton.addEventListener('click', function () {
            var isHidden = chatWidgetContainer.classList.contains('d-none');
            if (isHidden) {
              chatWidgetContainer.classList.remove('d-none');
              localStorage.setItem(_this8.chatWidgetStateName, 'open');
              _this8.reloadCurrentSession();
            } else {
              chatWidgetContainer.classList.add('d-none');
              localStorage.setItem(_this8.chatWidgetStateName, 'closed');
            }
          });
          if (config.widget.closeChatButton) {
            var closeChatButton = document.querySelector(config.widget.closeChatButton);
            if (closeChatButton) {
              closeChatButton.addEventListener('click', function () {
                chatWidgetContainer.classList.add('d-none');
                localStorage.setItem(_this8.chatWidgetStateName, 'closed');
              });
            }
          }
          if (config.widget.showHistoryButton && this.chatHistorySection) {
            var showHistoryButton = document.querySelector(config.widget.showHistoryButton);
            if (showHistoryButton) {
              showHistoryButton.addEventListener('click', function () {
                _this8.chatHistorySection.classList.toggle('show');
              });
            }
            if (config.widget.closeHistoryButton) {
              var closeHistoryButton = document.querySelector(config.widget.closeHistoryButton);
              if (closeHistoryButton) {
                closeHistoryButton.addEventListener('click', function () {
                  _this8.showChatScreen();
                });
              }
            }
          }
          if (config.widget.newChatButton) {
            var newChatButton = document.querySelector(config.widget.newChatButton);
            if (newChatButton) {
              newChatButton.addEventListener('click', function () {
                _this8.resetSession();
                _this8.showChatScreen();
              });
            }
          }
        },
        showChatScreen: function showChatScreen() {
          if (!this.chatHistorySection) {
            return;
          }
          this.chatHistorySection.classList.remove('show');
        },
        getSessionId: function getSessionId() {
          var sessionId = this.inputElement.getAttribute('data-session-id');
          if (!sessionId && this.widgetIsInitialized) {
            sessionId = localStorage.getItem(this.chatWidgetStateSession);
          }
          return sessionId;
        },
        copyResponse: function copyResponse(message) {
          navigator.clipboard.writeText(message);
        }
      },
      mounted: function mounted() {
        var _this9 = this;
        _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
          return _regenerator().w(function (_context2) {
            while (1) switch (_context2.n) {
              case 0:
                _context2.n = 1;
                return _this9.startConnection();
              case 1:
                _this9.initializeApp();
                if (config.widget) {
                  _this9.initializeWidget();
                }
              case 2:
                return _context2.a(2);
            }
          }, _callee2);
        }))();
        window.addEventListener('beforeunload', this.handleBeforeUnload);
      },
      beforeUnmount: function beforeUnmount() {
        window.removeEventListener('beforeunload', this.handleBeforeUnload);
        if (this.stream) {
          this.stream.dispose();
          this.stream = null;
        }
        if (this.connection) {
          this.connection.stop();
        }
      },
      template: config.messageTemplate
    }).mount(config.appElementSelector);
    return app;
  };
  return {
    initialize: initialize
  };
}();

// Global function for downloading charts as images
window.downloadChart = function (chartId) {
  var canvas = document.getElementById(chartId);
  if (!canvas) {
    console.error('Chart canvas not found:', chartId);
    return;
  }
  var link = document.createElement('a');
  link.download = 'chart-' + chartId + '.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
};

// Intercept download clicks for data-URI images and convert to blob downloads.
document.addEventListener('click', function (e) {
  var link = e.target.closest('.ai-download-image');
  if (!link) {
    return;
  }
  var container = link.closest('.generated-image-container');
  var img = container === null || container === void 0 ? void 0 : container.querySelector('img');
  if (!img) {
    return;
  }
  var src = img.src;
  if (!src || !src.startsWith('data:')) {
    return; // Normal URL â€“ let the default <a> behaviour handle it.
  }
  e.preventDefault();
  fetch(src).then(function (res) {
    return res.blob();
  }).then(function (blob) {
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url;
    a.download = link.getAttribute('download') || 'generated-image.png';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(function () {
      URL.revokeObjectURL(url);
    }, 100);
  })["catch"](function (err) {
    console.error('Failed to download image:', err);
  });
});