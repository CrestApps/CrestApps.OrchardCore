/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
window.openAIChatManager = function () {
  // Defaults (can be overridden by instanceConfig)
  var defaultConfig = {
    // UI defaults for generated media
    generatedImageAltText: 'Generated Image',
    generatedImageMaxWidth: 400,
    generatedChartMaxWidth: 900,
    downloadImageTitle: 'Download image',
    downloadChartTitle: 'Download chart as image',
    downloadChartButtonText: 'Download',
    userLabel: 'You',
    assistantLabel: 'Assistant',
    thumbsUpTitle: 'Thumbs up',
    thumbsDownTitle: 'Thumbs down',
    copyTitle: 'Click here to copy response to clipboard.',
    messageTemplate: "\n        <div class=\"ai-chat-messages\">\n            <div v-for=\"(message, index) in messages\" :key=\"index\" class=\"ai-chat-message-item\">\n                <div>\n                    <div v-if=\"message.role === 'user'\" class=\"ai-chat-msg-role ai-chat-msg-role-user\">{{ userLabel }}</div>\n                    <div v-else-if=\"message.role !== 'indicator'\" class=\"ai-chat-msg-role ai-chat-msg-role-assistant\">\n                        <i :class=\"'fa fa-robot' + (message.isStreaming ? ' ai-streaming-icon' : ' ai-bot-icon')\"></i>\n                        {{ assistantLabel }}\n                    </div>\n                    <div class=\"lh-base\">\n                        <h4 v-if=\"message.title\">{{ message.title }}</h4>\n                        <div v-html=\"message.htmlContent || message.content\"></div>\n                        <span class=\"message-buttons-container\" v-if=\"!isIndicator(message)\">\n                            <template v-if=\"metricsEnabled && message.role === 'assistant'\">\n                                <span class=\"ai-chat-message-assistant-feedback\" :data-message-id=\"message.id\">\n                                    <button class=\"btn btn-sm btn-link text-success p-0 me-2 button-message-toolbox rate-up-btn\" @click=\"rateMessage(message, true, $event)\" :title=\"thumbsUpTitle\">\n                                        <i class=\"fa-regular fa-thumbs-up\"></i>\n                                    </button>\n                                    <button class=\"btn btn-sm btn-link text-danger p-0 me-2 button-message-toolbox rate-down-btn\" @click=\"rateMessage(message, false, $event)\" :title=\"thumbsDownTitle\">\n                                        <i class=\"fa-regular fa-thumbs-down\"></i>\n                                    </button>\n                                </span>\n                            </template>\n                            <button class=\"btn btn-sm btn-link text-secondary p-0 button-message-toolbox\" @click=\"copyResponse(message.content)\" :title=\"copyTitle\">\n                                <i class=\"fa-solid fa-copy\"></i>\n                            </button>\n                        </span>\n                    </div>\n                </div>\n            </div>\n        </div>\n    ",
    indicatorTemplate: "\n        <div class=\"ai-chat-msg-role ai-chat-msg-role-assistant\">\n            <i class=\"fa fa-robot ai-streaming-icon\" style=\"display: inline-block;\"></i>\n            Assistant\n        </div>\n    "
  };

  // Sanitize URLs to prevent javascript: protocol injection.
  function sanitizeUrl(url) {
    if (!url) return '';
    var trimmed = url.trim();
    if (/^javascript:/i.test(trimmed) || /^vbscript:/i.test(trimmed) || /^data:text\/html/i.test(trimmed)) {
      return '';
    }
    return url;
  }
  var renderer = new marked.Renderer();

  // Modify the link rendering to open in a new tab
  renderer.link = function (data) {
    var href = sanitizeUrl(data.href);
    if (!href) return data.text || '';
    return "<a href=\"".concat(href, "\" target=\"_blank\" rel=\"noopener noreferrer\">").concat(data.text, "</a>");
  };

  // Custom code block renderer with highlight.js integration and copy button.
  renderer.code = function (data) {
    var code = data.text || '';
    var lang = (data.lang || '').trim();
    var highlighted = code;
    if (typeof hljs !== 'undefined') {
      if (lang && hljs.getLanguage(lang)) {
        try {
          highlighted = hljs.highlight(code, {
            language: lang
          }).value;
        } catch (_) {}
      } else {
        try {
          highlighted = hljs.highlightAuto(code).value;
        } catch (_) {}
      }
    } else {
      highlighted = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
    var langLabel = lang ? " data-lang=\"".concat(lang, "\"") : '';
    return "<pre".concat(langLabel, "><button type=\"button\" class=\"ai-code-copy-btn\" title=\"Copy code\"><i class=\"fa-solid fa-copy\"></i></button><code class=\"hljs").concat(lang ? ' language-' + lang : '', "\">").concat(highlighted, "</code></pre>");
  };

  // Custom image renderer for generated images with thumbnail styling and download button.
  // Handles both URL and data-URI sources (data URIs are converted to blobs for download).
  renderer.image = function (data) {
    var src = sanitizeUrl(data.href);
    if (!src) return '';
    var alt = data.text || defaultConfig.generatedImageAltText;
    var maxWidth = defaultConfig.generatedImageMaxWidth;
    return "<div class=\"generated-image-container\">\n        <img src=\"".concat(src, "\" alt=\"").concat(alt, "\" class=\"img-thumbnail\" style=\"max-width: ").concat(maxWidth, "px; height: auto;\" />\n        <div class=\"mt-2\">\n            <a href=\"").concat(src, "\" target=\"_blank\" download=\"").concat(alt, "\" title=\"").concat(defaultConfig.downloadImageTitle, "\" class=\"btn btn-sm btn-outline-secondary ai-download-image\">\n                <i class=\"fa-solid fa-download\"></i>\n            </a>\n        </div>\n    </div>");
  };

  // Chart counter for unique IDs
  var chartCounter = 0;

  // Collector for charts discovered during marked parsing.
  var _pendingCharts = [];
  function createChartHtml(chartId) {
    var chartMaxWidth = defaultConfig.generatedChartMaxWidth;
    return "<div class=\"chart-container\" style=\"position: relative; width: 100%; max-width: ".concat(chartMaxWidth, "px; margin: 0 auto; height: 480px;\">") + "<canvas id=\"".concat(chartId, "\" class=\"img-thumbnail\" width=\"").concat(chartMaxWidth, "\" height=\"480\" style=\"width: 100%; height: 480px;\"></canvas>") + "</div>" + "<div class=\"mt-2\">" + "<button type=\"button\" class=\"btn btn-sm btn-outline-secondary\" onclick=\"downloadChart('".concat(chartId, "')\" title=\"").concat(defaultConfig.downloadChartTitle, "\">") + "<i class=\"fa-solid fa-download\"></i> ".concat(defaultConfig.downloadChartButtonText) + "</button>" + "</div>";
  }

  // Register [chart:{...json...}] as a native marked block extension so the
  // markdown parser handles chart markers inline with surrounding text.
  marked.use({
    extensions: [{
      name: 'chart',
      level: 'block',
      start: function start(src) {
        var idx = src.indexOf('[chart:');
        return idx >= 0 ? idx : undefined;
      },
      tokenizer: function tokenizer(src) {
        var extracted = tryExtractChartMarker(src);
        if (!extracted || extracted.startIndex !== 0) {
          return undefined;
        }
        var chartId = "chat_chart_".concat(++chartCounter);
        return {
          type: 'chart',
          raw: src.substring(0, extracted.endIndex),
          chartId: chartId,
          json: extracted.json
        };
      },
      renderer: function renderer(token) {
        _pendingCharts.push({
          chartId: token.chartId,
          config: token.json
        });
        return createChartHtml(token.chartId);
      }
    }]
  });

  // Extract a [chart:{...json...}] marker. This avoids regex issues with nested brackets.
  function tryExtractChartMarker(text) {
    var token = '[chart:';
    var start = text.indexOf(token);
    if (start < 0) {
      return null;
    }

    // Find JSON object boundary by balancing braces
    var jsonStart = start + token.length;
    var i = jsonStart;
    while (i < text.length && (text[i] === ' ' || text[i] === '\n' || text[i] === '\r' || text[i] === '\t')) {
      i++;
    }
    if (i >= text.length || text[i] !== '{') {
      return null;
    }
    var depth = 0;
    var inString = false;
    var escape = false;
    for (; i < text.length; i++) {
      var ch = text[i];
      if (inString) {
        if (escape) {
          escape = false;
          continue;
        }
        if (ch === '\\') {
          escape = true;
          continue;
        }
        if (ch === '"') {
          inString = false;
        }
        continue;
      }
      if (ch === '"') {
        inString = true;
        continue;
      }
      if (ch === '{') {
        depth++;
      } else if (ch === '}') {
        depth--;
        if (depth === 0) {
          var jsonEnd = i;
          // Expect closing bracket after JSON
          var closeBracketIndex = text.indexOf(']', jsonEnd + 1);
          if (closeBracketIndex < 0) {
            return null;
          }
          var json = text.substring(jsonStart, jsonEnd + 1).trim();
          return {
            startIndex: start,
            endIndex: closeBracketIndex + 1,
            json: json
          };
        }
      }
    }
    return null;
  }
  function renderChartsInMessage(message) {
    if (!message || !message._pendingCharts || !message._pendingCharts.length) {
      return;
    }
    var _iterator = _createForOfIteratorHelper(message._pendingCharts),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var c = _step.value;
        var canvas = document.getElementById(c.chartId);
        if (!canvas) {
          continue;
        }
        if (typeof Chart === 'undefined') {
          console.error('Chart.js is not available on the page.');
          continue;
        }
        try {
          var _cfg$options;
          // Destroy existing chart instance if re-rendering
          if (canvas._chartInstance) {
            canvas._chartInstance.destroy();
          }
          var cfg = typeof c.config === 'string' ? JSON.parse(c.config) : c.config;
          (_cfg$options = cfg.options) !== null && _cfg$options !== void 0 ? _cfg$options : cfg.options = {};
          cfg.options.responsive = true;
          cfg.options.maintainAspectRatio = false;
          canvas._chartInstance = new Chart(canvas, cfg);
        } catch (e) {
          console.error('Error creating chart:', e);
        }
      }

      // Prevent re-render work
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    message._pendingCharts = [];
  }

  // Parse markdown content via marked (which natively handles [chart:...] markers
  // through the registered extension) and collect pending chart configs for later
  // Chart.js rendering.
  function parseMarkdownContent(content, message) {
    _pendingCharts = [];
    var html = marked.parse(content, {
      renderer: renderer
    });
    message._pendingCharts = _pendingCharts.length > 0 ? _toConsumableArray(_pendingCharts) : [];
    return html;
  }
  var initialize = function initialize(instanceConfig) {
    var config = Object.assign({}, defaultConfig, instanceConfig);
    // Keep defaultConfig in sync so renderers use overridden values
    defaultConfig = config;
    if (!config.signalRHubUrl) {
      console.error('The signalRHubUrl is required.');
      return;
    }
    if (!config.appElementSelector) {
      console.error('The appElementSelector is required.');
      return;
    }
    if (!config.chatContainerElementSelector) {
      console.error('The chatContainerElementSelector is required.');
      return;
    }
    if (!config.inputElementSelector) {
      console.error('The inputElementSelector is required.');
      return;
    }
    if (!config.sendButtonElementSelector) {
      console.error('The sendButtonElementSelector is required.');
      return;
    }
    var app = Vue.createApp({
      data: function data() {
        return {
          inputElement: null,
          buttonElement: null,
          chatContainer: null,
          placeholder: null,
          isSessionStarted: false,
          isPlaceholderVisible: true,
          chatWidgetStateName: null,
          chatWidgetStateSession: null,
          chatHistorySection: null,
          widgetIsInitialized: false,
          isSteaming: false,
          isNavigatingAway: false,
          autoScroll: true,
          stream: null,
          messages: [],
          prompt: '',
          documents: config.existingDocuments || [],
          isUploading: false,
          isDragOver: false,
          documentBar: null,
          metricsEnabled: !!config.metricsEnabled,
          userLabel: config.userLabel,
          assistantLabel: config.assistantLabel,
          thumbsUpTitle: config.thumbsUpTitle,
          thumbsDownTitle: config.thumbsDownTitle,
          copyTitle: config.copyTitle
        };
      },
      methods: {
        handleBeforeUnload: function handleBeforeUnload() {
          this.isNavigatingAway = true;
        },
        handleDragOver: function handleDragOver(e) {
          if (!config.sessionDocumentsEnabled) return;
          e.preventDefault();
          e.stopPropagation();
          this.isDragOver = true;
          var inputArea = this.inputElement ? this.inputElement.closest('.ai-admin-widget-input, .text-bg-light') : null;
          if (inputArea) inputArea.classList.add('ai-chat-drag-over');
        },
        handleDragLeave: function handleDragLeave(e) {
          if (!config.sessionDocumentsEnabled) return;
          e.preventDefault();
          e.stopPropagation();
          this.isDragOver = false;
          var inputArea = this.inputElement ? this.inputElement.closest('.ai-admin-widget-input, .text-bg-light') : null;
          if (inputArea) inputArea.classList.remove('ai-chat-drag-over');
        },
        handleDrop: function handleDrop(e) {
          if (!config.sessionDocumentsEnabled) return;
          e.preventDefault();
          e.stopPropagation();
          this.isDragOver = false;
          var inputArea = this.inputElement ? this.inputElement.closest('.ai-admin-widget-input, .text-bg-light') : null;
          if (inputArea) inputArea.classList.remove('ai-chat-drag-over');
          if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length > 0) {
            this.uploadFiles(e.dataTransfer.files);
          }
        },
        triggerFileInput: function triggerFileInput() {
          if (!config.sessionDocumentsEnabled) return;
          var fileInput = document.getElementById('ai-chat-doc-input');
          if (fileInput) fileInput.click();
        },
        handleFileInputChange: function handleFileInputChange(e) {
          var files = e.target.files;
          if (files && files.length > 0) {
            this.uploadFiles(files);
          }
          e.target.value = '';
        },
        uploadFiles: function uploadFiles(files) {
          var _this = this;
          return _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
            var sessionId, profileId, formData, i, response, errorText, result, j, k, _t;
            return _regenerator().w(function (_context) {
              while (1) switch (_context.p = _context.n) {
                case 0:
                  if (config.uploadDocumentUrl) {
                    _context.n = 1;
                    break;
                  }
                  return _context.a(2);
                case 1:
                  sessionId = _this.getSessionId();
                  profileId = _this.getProfileId();
                  if (!(!sessionId && !profileId)) {
                    _context.n = 2;
                    break;
                  }
                  console.warn('Cannot upload documents without a session or profile.');
                  return _context.a(2);
                case 2:
                  _this.isUploading = true;
                  _context.p = 3;
                  formData = new FormData();
                  if (sessionId) {
                    formData.append('sessionId', sessionId);
                  } else {
                    formData.append('profileId', profileId);
                  }
                  for (i = 0; i < files.length; i++) {
                    formData.append('files', files[i]);
                  }
                  _context.n = 4;
                  return fetch(config.uploadDocumentUrl, {
                    method: 'POST',
                    body: formData
                  });
                case 4:
                  response = _context.v;
                  if (response.ok) {
                    _context.n = 6;
                    break;
                  }
                  _context.n = 5;
                  return response.text();
                case 5:
                  errorText = _context.v;
                  console.error('Upload failed:', errorText);
                  return _context.a(2);
                case 6:
                  _context.n = 7;
                  return response.json();
                case 7:
                  result = _context.v;
                  // If the server created a new session, initialize it.
                  if (result.sessionId && !sessionId) {
                    _this.initializeSession(result.sessionId);
                  }
                  if (result.uploaded && result.uploaded.length > 0) {
                    for (j = 0; j < result.uploaded.length; j++) {
                      _this.documents.push(result.uploaded[j]);
                    }
                  }
                  if (result.failed && result.failed.length > 0) {
                    for (k = 0; k < result.failed.length; k++) {
                      console.warn('File failed to upload:', result.failed[k].fileName, result.failed[k].error);
                    }
                  }
                  _context.n = 9;
                  break;
                case 8:
                  _context.p = 8;
                  _t = _context.v;
                  console.error('Upload error:', _t);
                case 9:
                  _context.p = 9;
                  _this.isUploading = false;
                  return _context.f(9);
                case 10:
                  return _context.a(2);
              }
            }, _callee, null, [[3, 8, 9, 10]]);
          }))();
        },
        removeDocument: function removeDocument(doc) {
          var _this2 = this;
          return _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
            var sessionId, response, idx, errorText, _t2;
            return _regenerator().w(function (_context2) {
              while (1) switch (_context2.p = _context2.n) {
                case 0:
                  if (config.removeDocumentUrl) {
                    _context2.n = 1;
                    break;
                  }
                  return _context2.a(2);
                case 1:
                  _context2.p = 1;
                  sessionId = _this2.getSessionId();
                  _context2.n = 2;
                  return fetch(config.removeDocumentUrl, {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                      itemId: sessionId,
                      documentId: doc.documentId
                    })
                  });
                case 2:
                  response = _context2.v;
                  if (!response.ok) {
                    _context2.n = 3;
                    break;
                  }
                  idx = _this2.documents.indexOf(doc);
                  if (idx > -1) _this2.documents.splice(idx, 1);
                  _context2.n = 5;
                  break;
                case 3:
                  _context2.n = 4;
                  return response.text();
                case 4:
                  errorText = _context2.v;
                  console.error('Failed to remove document:', response.status, errorText);
                case 5:
                  _context2.n = 7;
                  break;
                case 6:
                  _context2.p = 6;
                  _t2 = _context2.v;
                  console.error('Remove document error:', _t2);
                case 7:
                  return _context2.a(2);
              }
            }, _callee2, null, [[1, 6]]);
          }))();
        },
        formatFileSize: function formatFileSize(bytes) {
          if (bytes < 1024) return bytes + ' B';
          if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
          return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        },
        renderDocumentBar: function renderDocumentBar() {
          if (!this.documentBar) return;
          if (!config.sessionDocumentsEnabled) {
            this.documentBar.classList.add('d-none');
            return;
          }
          this.documentBar.classList.remove('d-none');
          var html = '<div class="ai-chat-doc-bar d-flex flex-wrap align-items-center gap-1 p-2">';
          for (var i = 0; i < this.documents.length; i++) {
            var doc = this.documents[i];
            var name = doc.fileName || 'Document';
            if (name.length > 20) name = name.substring(0, 17) + '...';
            html += '<span class="badge bg-secondary bg-opacity-25 text-dark d-inline-flex align-items-center gap-1 px-2 py-1" style="font-size: 0.8rem;" title="' + this.escapeHtml(doc.fileName || '') + '">';
            html += '<i class="fa-solid fa-file-lines" style="font-size: 0.7rem;"></i> ';
            html += this.escapeHtml(name);
            html += ' <button type="button" class="btn-close btn-close-sm ms-1" style="font-size: 0.5rem;" data-doc-index="' + i + '" aria-label="Remove"></button>';
            html += '</span>';
          }
          if (this.isUploading) {
            html += '<span class="badge bg-info bg-opacity-25 text-dark d-inline-flex align-items-center gap-1 px-2 py-1" style="font-size: 0.8rem;">';
            html += '<span class="spinner-border spinner-border-sm" style="width: 0.7rem; height: 0.7rem;"></span> Uploading...';
            html += '</span>';
          }
          html += '<button type="button" class="btn btn-sm btn-outline-secondary rounded-pill ai-chat-doc-add-btn d-inline-flex align-items-center gap-1" style="font-size: 0.75rem; padding: 0.15rem 0.5rem;" title="Attach documents">';
          html += '<i class="fa-solid fa-paperclip"></i>';
          if (this.documents.length === 0 && !this.isUploading) {
            html += ' <span>Attach files</span>';
          }
          html += '</button>';
          html += '</div>';
          this.documentBar.innerHTML = html;

          // Bind remove handlers
          var self = this;
          var closeButtons = this.documentBar.querySelectorAll('.btn-close');
          for (var j = 0; j < closeButtons.length; j++) {
            closeButtons[j].addEventListener('click', function (idx) {
              return function (e) {
                e.preventDefault();
                e.stopPropagation();
                var docToRemove = self.documents[idx];
                if (docToRemove) self.removeDocument(docToRemove);
              };
            }(parseInt(closeButtons[j].getAttribute('data-doc-index'))));
          }

          // Bind add button
          var addBtn = this.documentBar.querySelector('.ai-chat-doc-add-btn');
          if (addBtn) {
            addBtn.addEventListener('click', function (e) {
              e.preventDefault();
              self.triggerFileInput();
            });
          }
        },
        escapeHtml: function escapeHtml(text) {
          var div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        },
        startConnection: function startConnection() {
          var _this3 = this;
          return _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
            var _t3;
            return _regenerator().w(function (_context3) {
              while (1) switch (_context3.p = _context3.n) {
                case 0:
                  _this3.connection = new signalR.HubConnectionBuilder().withUrl(config.signalRHubUrl).withAutomaticReconnect().build();

                  // Allow long-running operations (e.g., multi-step MCP tool calls)
                  // without the client disconnecting prematurely.
                  _this3.connection.serverTimeoutInMilliseconds = 600000;
                  _this3.connection.keepAliveIntervalInMilliseconds = 15000;
                  _this3.connection.on("LoadSession", function (data) {
                    var _data$messages;
                    _this3.initializeSession(data.sessionId, true);
                    _this3.messages = [];
                    _this3.documents = data.documents || [];
                    ((_data$messages = data.messages) !== null && _data$messages !== void 0 ? _data$messages : []).forEach(function (msg) {
                      _this3.addMessage(msg);
                      _this3.$nextTick(function () {
                        renderChartsInMessage(msg);
                      });
                    });

                    // Update feedback icons in the DOM after all messages have rendered.
                    _this3.$nextTick(function () {
                      _this3.refreshAllFeedbackIcons();
                    });
                  });
                  _this3.connection.on("ReceiveError", function (error) {
                    console.error("SignalR Error: ", error);
                  });
                  _this3.connection.on("MessageRated", function (messageId, userRating) {
                    var msg = _this3.messages.find(function (m) {
                      return m.id === messageId;
                    });
                    if (msg) {
                      msg.userRating = userRating;
                    }
                  });
                  _this3.connection.onreconnecting(function () {
                    console.warn("SignalR: reconnecting...");
                  });
                  _this3.connection.onreconnected(function () {
                    console.info("SignalR: reconnected.");
                  });
                  _this3.connection.onclose(function (error) {
                    if (_this3.isNavigatingAway) {
                      return;
                    }
                    if (error) {
                      console.warn("SignalR connection closed with error:", error.message || error);
                    }
                  });
                  _context3.p = 1;
                  _context3.n = 2;
                  return _this3.connection.start();
                case 2:
                  _context3.n = 4;
                  break;
                case 3:
                  _context3.p = 3;
                  _t3 = _context3.v;
                  console.error("SignalR Connection Error: ", _t3);
                case 4:
                  return _context3.a(2);
              }
            }, _callee3, null, [[1, 3]]);
          }))();
        },
        addMessageInternal: function addMessageInternal(message) {
          var _this4 = this;
          this.fireEvent(new CustomEvent("addingOpenAIPromotMessage", {
            detail: {
              message: message
            }
          }));
          this.messages.push(message);
          this.$nextTick(function () {
            _this4.fireEvent(new CustomEvent("addedOpenAIPromotMessage", {
              detail: {
                message: message
              }
            }));
          });
        },
        addMessage: function addMessage(message) {
          var _this5 = this;
          // Ensure userRating is always defined for Vue reactivity.
          if (message.userRating === undefined) {
            message.userRating = null;
          }
          if (message.content) {
            var processedContent = message.content.trim();
            if (message.references && _typeof(message.references) === "object" && Object.keys(message.references).length) {
              // Only include references that were actually cited in the response.
              var citedRefs = Object.entries(message.references).filter(function (_ref) {
                var _ref2 = _slicedToArray(_ref, 1),
                  key = _ref2[0];
                return processedContent.includes(key);
              });
              if (citedRefs.length) {
                // Sort by original index so display indices follow a natural order.
                citedRefs.sort(function (_ref3, _ref4) {
                  var _ref5 = _slicedToArray(_ref3, 2),
                    a = _ref5[1];
                  var _ref6 = _slicedToArray(_ref4, 2),
                    b = _ref6[1];
                  return a.index - b.index;
                });

                // Phase 1: Replace all markers with unique placeholders.
                var displayIndex = 1;
                var _iterator2 = _createForOfIteratorHelper(citedRefs),
                  _step2;
                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    var _step2$value = _slicedToArray(_step2.value, 2),
                      key = _step2$value[0],
                      value = _step2$value[1];
                    var placeholder = "__CITE_".concat(value.index, "__");
                    processedContent = processedContent.replaceAll(key, placeholder);
                    value._displayIndex = displayIndex++;
                    value._placeholder = placeholder;
                  }

                  // Phase 2: Replace placeholders with sequential display indices.
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }
                var _iterator3 = _createForOfIteratorHelper(citedRefs),
                  _step3;
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    var _step3$value = _slicedToArray(_step3.value, 2),
                      _value = _step3$value[1];
                    processedContent = processedContent.replaceAll(_value._placeholder, "<sup><strong>".concat(_value._displayIndex, "</strong></sup>"));
                  }

                  // if we have multiple references, add a comma to ensure we don't concatenate numbers.
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
                processedContent = processedContent.replaceAll('</strong></sup><sup>', '</strong></sup><sup>,</sup><sup>');
                processedContent += '<br><br>';
                var _iterator4 = _createForOfIteratorHelper(citedRefs),
                  _step4;
                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                    var _step4$value = _slicedToArray(_step4.value, 2),
                      _key = _step4$value[0],
                      _value2 = _step4$value[1];
                    var label = _value2.text || _key;
                    processedContent += _value2.link ? "**".concat(_value2._displayIndex, "**. [").concat(label, "](").concat(_value2.link, ")<br>") : "**".concat(_value2._displayIndex, "**. ").concat(label, "<br>");
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }
              }
            }
            message.content = processedContent;
            message.htmlContent = parseMarkdownContent(processedContent, message);
          }
          this.addMessageInternal(message);
          this.hidePlaceholder();
          this.$nextTick(function () {
            // Render any pending charts once the DOM is updated
            renderChartsInMessage(message);
            _this5.scrollToBottom();
          });
        },
        addMessages: function addMessages(messages) {
          var _this6 = this;
          for (var i = 0; i < messages.length; i++) {
            this.addMessageInternal(messages[i]);
          }
          this.hidePlaceholder();
          this.$nextTick(function () {
            _this6.scrollToBottom();
          });
        },
        hidePlaceholder: function hidePlaceholder() {
          if (this.placeholder) {
            this.placeholder.classList.add('d-none');
          }
          this.isPlaceholderVisible = false;
        },
        showPlaceholder: function showPlaceholder() {
          if (this.placeholder) {
            this.placeholder.classList.remove('d-none');
          }
          this.isPlaceholderVisible = true;
        },
        fireEvent: function fireEvent(event) {
          document.dispatchEvent(event);
        },
        isIndicator: function isIndicator(message) {
          return message.role === 'indicator';
        },
        sendMessage: function sendMessage() {
          var trimmedPrompt = this.prompt.trim();
          if (!trimmedPrompt) {
            return;
          }
          this.addMessage({
            role: 'user',
            content: trimmedPrompt
          });
          this.streamMessage(this.getProfileId(), trimmedPrompt, null);
          this.inputElement.value = '';
          this.prompt = '';
        },
        streamMessage: function streamMessage(profileId, trimmedPrompt, sessionProfileId) {
          var _this7 = this;
          if (this.stream) {
            this.stream.dispose();
            this.stream = null;
          }
          this.streamingStarted();
          this.showTypingIndicator();
          this.autoScroll = true;
          var content = '';
          var references = {};

          // Get the index after showing typing indicator.
          var messageIndex = this.messages.length;
          var currentSessionId = this.getSessionId();
          this.stream = this.connection.stream("SendMessage", profileId, trimmedPrompt, currentSessionId, sessionProfileId).subscribe({
            next: function next(chunk) {
              var message = _this7.messages[messageIndex];
              if (!message) {
                if (chunk.sessionId && !currentSessionId) {
                  _this7.initializeSession(chunk.sessionId);
                }
                _this7.hideTypingIndicator();
                // Re-assign the index after hiding the typing indicator.
                messageIndex = _this7.messages.length;
                var newMessage = {
                  id: chunk.messageId,
                  role: "assistant",
                  title: chunk.title,
                  content: "",
                  htmlContent: "",
                  isStreaming: true,
                  userRating: null
                };
                _this7.messages.push(newMessage);
                message = newMessage;
              }
              if (chunk.title && (!message.title || message.title !== chunk.title)) {
                message.title = chunk.title;
              }
              if (chunk.references && _typeof(chunk.references) === "object" && Object.keys(chunk.references).length) {
                for (var _i = 0, _Object$entries = Object.entries(chunk.references); _i < _Object$entries.length; _i++) {
                  var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                    key = _Object$entries$_i[0],
                    value = _Object$entries$_i[1];
                  references[key] = value;
                }
              }
              if (chunk.content) {
                var processedContent = chunk.content;
                for (var _i2 = 0, _Object$entries2 = Object.entries(references); _i2 < _Object$entries2.length; _i2++) {
                  var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
                    _key2 = _Object$entries2$_i[0],
                    _value3 = _Object$entries2$_i[1];
                  processedContent = processedContent.replaceAll(_key2, "<sup><strong>".concat(_value3.index, "</strong></sup>"));
                }

                // Append processed content to the message.
                // if we have multiple references, add a comma to ensure we don't concatenate numbers.
                content += processedContent.replaceAll('</strong></sup><sup>', '</strong></sup><sup>,</sup><sup>');
              }

              // Update the existing message
              message.content = content;
              message.htmlContent = parseMarkdownContent(content, message);
              _this7.messages[messageIndex] = message;
              _this7.$nextTick(function () {
                renderChartsInMessage(message);
                _this7.scrollToBottom();
              });
            },
            complete: function complete() {
              var _this7$stream;
              _this7.processReferences(references, messageIndex);
              _this7.streamingFinished();
              var msg = _this7.messages[messageIndex];
              if (msg) {
                msg.isStreaming = false;
              }
              if (!msg || !msg.content) {
                // No content received at all.
                _this7.hideTypingIndicator();
              }
              (_this7$stream = _this7.stream) === null || _this7$stream === void 0 || _this7$stream.dispose();
              _this7.stream = null;
            },
            error: function error(err) {
              var _this7$stream2;
              _this7.processReferences(references, messageIndex);
              _this7.streamingFinished();
              var msg = _this7.messages[messageIndex];
              if (msg) {
                msg.isStreaming = false;
              }
              _this7.hideTypingIndicator();
              if (!_this7.isNavigatingAway) {
                _this7.addMessage(_this7.getServiceDownMessage());
              }
              (_this7$stream2 = _this7.stream) === null || _this7$stream2 === void 0 || _this7$stream2.dispose();
              _this7.stream = null;
              console.error("Stream error:", err);
            }
          });
        },
        getServiceDownMessage: function getServiceDownMessage() {
          var newMessage = {
            role: "assistant",
            content: "Our service is currently unavailable. Please try again later. We apologize for the inconvenience.",
            htmlContent: ""
          };
          return newMessage;
        },
        processReferences: function processReferences(references, messageIndex) {
          if (Object.keys(references).length) {
            var message = this.messages[messageIndex];
            var content = message.content || '';

            // Only include references that were actually cited in the response.
            // Check both raw [doc:N] markers and already-rendered <sup> tags from streaming.
            var citedRefs = Object.entries(references).filter(function (_ref7) {
              var _ref8 = _slicedToArray(_ref7, 2),
                key = _ref8[0],
                value = _ref8[1];
              return content.includes(key) || content.includes("<sup><strong>".concat(value.index, "</strong></sup>"));
            });
            if (!citedRefs.length) {
              return;
            }

            // Sort by original index so display indices follow a natural order.
            citedRefs.sort(function (_ref9, _ref0) {
              var _ref1 = _slicedToArray(_ref9, 2),
                a = _ref1[1];
              var _ref10 = _slicedToArray(_ref0, 2),
                b = _ref10[1];
              return a.index - b.index;
            });

            // Phase 1: Replace all markers with unique placeholders to avoid collisions during remapping.
            var processed = content.trim();
            var displayIndex = 1;
            var _iterator5 = _createForOfIteratorHelper(citedRefs),
              _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var _step5$value = _slicedToArray(_step5.value, 2),
                  key = _step5$value[0],
                  value = _step5$value[1];
                var placeholder = "__CITE_".concat(value.index, "__");
                processed = processed.replaceAll(key, placeholder);
                processed = processed.replaceAll("<sup><strong>".concat(value.index, "</strong></sup>"), placeholder);
                value._displayIndex = displayIndex++;
                value._placeholder = placeholder;
              }

              // Phase 2: Replace placeholders with sequential display indices.
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
            var _iterator6 = _createForOfIteratorHelper(citedRefs),
              _step6;
            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var _step6$value = _slicedToArray(_step6.value, 2),
                  _value4 = _step6$value[1];
                processed = processed.replaceAll(_value4._placeholder, "<sup><strong>".concat(_value4._displayIndex, "</strong></sup>"));
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
            processed = processed.replaceAll('</strong></sup><sup>', '</strong></sup><sup>,</sup><sup>');
            processed += '<br><br>';
            var _iterator7 = _createForOfIteratorHelper(citedRefs),
              _step7;
            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                var _step7$value = _slicedToArray(_step7.value, 2),
                  _key3 = _step7$value[0],
                  _value5 = _step7$value[1];
                var label = _value5.text || _key3;
                processed += _value5.link ? "**".concat(_value5._displayIndex, "**. [").concat(label, "](").concat(_value5.link, ")<br>") : "**".concat(_value5._displayIndex, "**. ").concat(label, "<br>");
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
            message.content = processed;
            message.htmlContent = parseMarkdownContent(processed, message);
            this.messages[messageIndex] = message;
            this.scrollToBottom();
          }
        },
        streamingStarted: function streamingStarted() {
          var stopIcon = this.buttonElement.getAttribute('data-stop-icon');
          if (stopIcon) {
            this.buttonElement.innerHTML = stopIcon;
          }
          if (this.inputElement) {
            this.inputElement.setAttribute('disabled', 'disabled');
          }
        },
        streamingFinished: function streamingFinished() {
          var startIcon = this.buttonElement.getAttribute('data-start-icon');
          if (startIcon) {
            this.buttonElement.innerHTML = startIcon;
          }
          if (this.inputElement) {
            this.inputElement.removeAttribute('disabled');
            this.inputElement.focus();
          }

          // Directly manipulate the DOM to stop all streaming animations.
          if (this.chatContainer) {
            var icons = this.chatContainer.querySelectorAll('.ai-streaming-icon');
            for (var i = 0; i < icons.length; i++) {
              icons[i].classList.remove('ai-streaming-icon');
              icons[i].classList.add('ai-bot-icon');
            }
          }

          // Also update Vue data for consistency.
          for (var i = 0; i < this.messages.length; i++) {
            if (this.messages[i].isStreaming) {
              this.messages[i].isStreaming = false;
            }
          }
        },
        generatePrompt: function generatePrompt(element) {
          if (!element) {
            console.error('The element paramter is required.');
            return;
          }
          var templateProfileId = element.getAttribute('data-profile-id');
          var sessionId = this.getSessionId();
          var sessionProfileId = this.getProfileId();
          if (!templateProfileId || !sessionId) {
            console.error('The given element is missing data-profile-id or the session has not yet started.');
            return;
          }

          // streamMessage() already shows the typing indicator.
          this.streamMessage(templateProfileId, null, sessionProfileId);
        },
        createSessionUrl: function createSessionUrl(baseUrl, param, value) {
          var fullUrl = baseUrl.toLowerCase().startsWith('http') ? baseUrl : window.location.origin + baseUrl;
          var url = new URL(fullUrl);
          url.searchParams.set(param, value);
          return url.toString();
        },
        showTypingIndicator: function showTypingIndicator() {
          this.addMessage({
            role: 'indicator',
            htmlContent: config.indicatorTemplate
          });
        },
        hideTypingIndicator: function hideTypingIndicator() {
          var originalLength = this.messages.length;
          this.messages = this.messages.filter(function (msg) {
            return msg.role !== 'indicator';
          });
          var removedCount = originalLength - this.messages.length;
          return removedCount;
        },
        scrollToBottom: function scrollToBottom() {
          var _this8 = this;
          if (!this.autoScroll) {
            return;
          }
          setTimeout(function () {
            _this8.chatContainer.scrollTop = _this8.chatContainer.scrollHeight - _this8.chatContainer.clientHeight;
          }, 50);
        },
        handleUserInput: function handleUserInput(event) {
          this.prompt = event.target.value;
        },
        getProfileId: function getProfileId() {
          return this.inputElement.getAttribute('data-profile-id');
        },
        setSessionId: function setSessionId(sessionId) {
          this.inputElement.setAttribute('data-session-id', sessionId || '');
        },
        resetSession: function resetSession() {
          this.setSessionId('');
          this.isSessionStarted = false;
          this.sessionRating = null;
          if (this.widgetIsInitialized) {
            localStorage.removeItem(this.chatWidgetStateSession);
          }
          this.messages = [];
          this.documents = [];
          this.showPlaceholder();
        },
        initializeApp: function initializeApp() {
          var _this9 = this;
          this.inputElement = document.querySelector(config.inputElementSelector);
          this.buttonElement = document.querySelector(config.sendButtonElementSelector);
          this.chatContainer = document.querySelector(config.chatContainerElementSelector);
          this.placeholder = document.querySelector(config.placeholderElementSelector);

          // Initialize document bar if enabled.
          if (config.sessionDocumentsEnabled && config.documentBarSelector) {
            this.documentBar = document.querySelector(config.documentBarSelector);
            if (this.documentBar) {
              this.renderDocumentBar();

              // Create hidden file input for document uploads.
              var fileInput = document.createElement('input');
              fileInput.type = 'file';
              fileInput.id = 'ai-chat-doc-input';
              fileInput.className = 'd-none';
              fileInput.multiple = true;
              if (config.allowedExtensions) {
                fileInput.accept = config.allowedExtensions;
              }
              fileInput.addEventListener('change', function (e) {
                return _this9.handleFileInputChange(e);
              });
              this.documentBar.parentElement.appendChild(fileInput);

              // Set up drag-and-drop on the input area.
              var inputArea = this.inputElement ? this.inputElement.closest('.ai-admin-widget-input, .text-bg-light') : null;
              if (inputArea) {
                inputArea.addEventListener('dragover', function (e) {
                  return _this9.handleDragOver(e);
                });
                inputArea.addEventListener('dragleave', function (e) {
                  return _this9.handleDragLeave(e);
                });
                inputArea.addEventListener('drop', function (e) {
                  return _this9.handleDrop(e);
                });
              }
            }
          }

          // Pause auto-scroll when the user manually scrolls up during streaming.
          this.chatContainer.addEventListener('scroll', function () {
            if (!_this9.stream) {
              return;
            }
            var threshold = 30;
            var atBottom = _this9.chatContainer.scrollHeight - _this9.chatContainer.clientHeight - _this9.chatContainer.scrollTop <= threshold;
            _this9.autoScroll = atBottom;
          });
          this.inputElement.addEventListener('keydown', function (event) {
            if (_this9.stream != null) {
              return;
            }
            if (event.key === "Enter" && !event.shiftKey) {
              event.preventDefault();
              _this9.buttonElement.click();
            }
          });
          this.inputElement.addEventListener('input', function (e) {
            _this9.handleUserInput(e);
            if (e.target.value.trim()) {
              _this9.buttonElement.removeAttribute('disabled');
            } else {
              _this9.buttonElement.setAttribute('disabled', true);
            }
          });
          this.buttonElement.addEventListener('click', function () {
            if (_this9.stream != null) {
              _this9.stream.dispose();
              _this9.stream = null;
              _this9.streamingFinished();
              _this9.hideTypingIndicator();

              // Clean up: remove empty assistant message or stop streaming animation.
              if (_this9.messages.length > 0) {
                var lastMsg = _this9.messages[_this9.messages.length - 1];
                if (lastMsg.role === 'assistant' && !lastMsg.content) {
                  _this9.messages.pop();
                } else if (lastMsg.isStreaming) {
                  lastMsg.isStreaming = false;
                }
              }
              return;
            }
            _this9.sendMessage();
          });
          var promptGenerators = document.getElementsByClassName('profile-generated-prompt');
          for (var i = 0; i < promptGenerators.length; i++) {
            promptGenerators[i].addEventListener('click', function (e) {
              e.preventDefault();
              _this9.generatePrompt(e.target);
            });
          }
          var chatSessions = document.getElementsByClassName('chat-session-history-item');
          for (var i = 0; i < chatSessions.length; i++) {
            chatSessions[i].addEventListener('click', function (e) {
              e.preventDefault();
              var sessionId = e.target.getAttribute('data-session-id');
              if (!sessionId) {
                console.error('an element with the class chat-session-history-item with no data-session-id set.');
                return;
              }
              _this9.loadSession(sessionId);
              _this9.showChatScreen();
            });
          }
          for (var _i3 = 0; _i3 < config.messages.length; _i3++) {
            this.addMessage(config.messages[_i3]);
          }

          // Update feedback icons in the DOM after initial messages have rendered.
          this.$nextTick(function () {
            _this9.refreshAllFeedbackIcons();
          });

          // Delegate click for code block copy buttons.
          if (this.chatContainer) {
            this.chatContainer.addEventListener('click', function (e) {
              var btn = e.target.closest('.ai-code-copy-btn');
              if (!btn) {
                return;
              }
              var pre = btn.closest('pre');
              if (!pre) {
                return;
              }
              var codeEl = pre.querySelector('code');
              if (codeEl) {
                navigator.clipboard.writeText(codeEl.textContent);
              }
            });
          }
        },
        loadSession: function loadSession(sessionId) {
          this.connection.invoke("LoadSession", sessionId)["catch"](function (err) {
            return console.error(err);
          });
        },
        reloadCurrentSession: function reloadCurrentSession() {
          var sessionId = this.getSessionId();
          if (sessionId) {
            this.loadSession(sessionId);
          }
        },
        initializeSession: function initializeSession(sessionId, force) {
          if (this.isSessionStarted && !force) {
            return;
          }
          this.fireEvent(new CustomEvent("initializingSessionOpenAIChat", {
            detail: {
              sessionId: sessionId
            }
          }));
          this.setSessionId(sessionId);
          this.isSessionStarted = true;
          if (this.widgetIsInitialized) {
            localStorage.setItem(this.chatWidgetStateSession, sessionId);
          }
        },
        initializeWidget: function initializeWidget() {
          var _this0 = this;
          if (!config.widget.chatWidgetContainer) {
            console.error('The widget chatWidgetContainer is required.');
            return;
          }
          if (!config.widget.chatWidgetStateName) {
            console.error('The widget chatWidgetStateName is required.');
            return;
          }
          var chatWidgetContainer = document.querySelector(config.widget.chatWidgetContainer);
          if (!chatWidgetContainer) {
            return;
          }
          if (config.widget.chatHistorySection) {
            this.chatHistorySection = document.querySelector(config.widget.chatHistorySection);
          }
          this.chatWidgetStateName = config.widget.chatWidgetStateName;
          this.chatWidgetStateSession = config.widget.chatWidgetStateName + 'Session';
          this.widgetIsInitialized = true;

          // Auto-load the last session so the user always sees previous chat history.
          this.reloadCurrentSession();
          if (config.widget.showHistoryButton && this.chatHistorySection) {
            var showHistoryButton = document.querySelector(config.widget.showHistoryButton);
            if (showHistoryButton) {
              showHistoryButton.addEventListener('click', function () {
                _this0.chatHistorySection.classList.toggle('show');
              });
            }
            if (config.widget.closeHistoryButton) {
              var closeHistoryButton = document.querySelector(config.widget.closeHistoryButton);
              if (closeHistoryButton) {
                closeHistoryButton.addEventListener('click', function () {
                  _this0.showChatScreen();
                });
              }
            }
          }
          if (config.widget.newChatButton) {
            var newChatButton = document.querySelector(config.widget.newChatButton);
            if (newChatButton) {
              newChatButton.addEventListener('click', function () {
                _this0.resetSession();
                _this0.showChatScreen();
              });
            }
          }
        },
        showChatScreen: function showChatScreen() {
          if (!this.chatHistorySection) {
            return;
          }
          this.chatHistorySection.classList.remove('show');
        },
        getSessionId: function getSessionId() {
          var sessionId = this.inputElement.getAttribute('data-session-id');
          if (!sessionId && this.widgetIsInitialized) {
            sessionId = localStorage.getItem(this.chatWidgetStateSession);
          }
          return sessionId;
        },
        copyResponse: function copyResponse(message) {
          navigator.clipboard.writeText(message);
        },
        updateFeedbackIcons: function updateFeedbackIcons(container, userRating) {
          if (!container) {
            return;
          }
          var upBtn = container.querySelector('.rate-up-btn');
          var downBtn = container.querySelector('.rate-down-btn');

          // Font Awesome SVG+JS replaces <i> with <svg>, so we must replace
          // the entire button content and let Font Awesome re-process.
          if (upBtn) {
            var upClass = userRating === true ? 'fa-solid fa-thumbs-up' : 'fa-regular fa-thumbs-up';
            upBtn.innerHTML = '<i class="' + upClass + '" style="font-size: 0.9rem;"></i>';
          }
          if (downBtn) {
            var downClass = userRating === false ? 'fa-solid fa-thumbs-down' : 'fa-regular fa-thumbs-down';
            downBtn.innerHTML = '<i class="' + downClass + '" style="font-size: 0.9rem;"></i>';
          }

          // Trigger Font Awesome SVG+JS to convert the new <i> elements.
          if (window.FontAwesome && FontAwesome.dom && FontAwesome.dom.i2svg) {
            FontAwesome.dom.i2svg({
              node: container
            });
          }
        },
        refreshAllFeedbackIcons: function refreshAllFeedbackIcons() {
          var containers = this.$el.querySelectorAll('.ai-chat-message-assistant-feedback');
          for (var i = 0; i < containers.length; i++) {
            var msgId = containers[i].getAttribute('data-message-id');
            var msg = this.messages.find(function (m) {
              return m.id === msgId;
            });
            if (msg) {
              this.updateFeedbackIcons(containers[i], msg.userRating);
            }
          }
        },
        rateMessage: function rateMessage(message, isPositive, event) {
          var sessionId = this.getSessionId();
          if (!sessionId || !message.id || !this.connection) {
            return;
          }

          // Toggle: clicking the same rating again clears it.
          var newRating = message.userRating === isPositive ? null : isPositive;
          message.userRating = newRating;

          // Find the feedback container by message ID for reliable DOM targeting.
          var feedbackContainer = this.$el.querySelector('.ai-chat-message-assistant-feedback[data-message-id="' + message.id + '"]');
          this.updateFeedbackIcons(feedbackContainer, newRating);

          // Trigger spark animation after Font Awesome has re-processed icons.
          if (newRating !== null && feedbackContainer) {
            setTimeout(function () {
              var btnClass = isPositive ? '.rate-up-btn' : '.rate-down-btn';
              var btn = feedbackContainer.querySelector(btnClass);
              if (btn) {
                btn.classList.remove('spark-effect');
                void btn.offsetWidth;
                btn.classList.add('spark-effect');
                btn.addEventListener('animationend', function onEnd() {
                  btn.removeEventListener('animationend', onEnd);
                  btn.classList.remove('spark-effect');
                });
              }
            }, 50);
          }
          this.connection.invoke("RateMessage", sessionId, message.id, isPositive)["catch"](function (err) {
            console.error('Failed to rate message:', err);
          });
        }
      },
      watch: {
        documents: {
          handler: function handler() {
            this.renderDocumentBar();
          },
          deep: true
        },
        isUploading: function isUploading() {
          this.renderDocumentBar();
        }
      },
      mounted: function mounted() {
        var _this1 = this;
        _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
          return _regenerator().w(function (_context4) {
            while (1) switch (_context4.n) {
              case 0:
                _context4.n = 1;
                return _this1.startConnection();
              case 1:
                _this1.initializeApp();
                if (config.widget) {
                  _this1.initializeWidget();
                }
              case 2:
                return _context4.a(2);
            }
          }, _callee4);
        }))();
        window.addEventListener('beforeunload', this.handleBeforeUnload);
      },
      beforeUnmount: function beforeUnmount() {
        window.removeEventListener('beforeunload', this.handleBeforeUnload);
        if (this.stream) {
          this.stream.dispose();
          this.stream = null;
        }
        if (this.connection) {
          this.connection.stop();
        }
      },
      template: config.messageTemplate
    }).mount(config.appElementSelector);
    return app;
  };
  return {
    initialize: initialize
  };
}();

// Global function for downloading charts as images
window.downloadChart = function (chartId) {
  var canvas = document.getElementById(chartId);
  if (!canvas) {
    console.error('Chart canvas not found:', chartId);
    return;
  }
  var link = document.createElement('a');
  link.download = 'chart-' + chartId + '.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
};

// Intercept download clicks for data-URI images and convert to blob downloads.
document.addEventListener('click', function (e) {
  var link = e.target.closest('.ai-download-image');
  if (!link) {
    return;
  }
  var container = link.closest('.generated-image-container');
  var img = container === null || container === void 0 ? void 0 : container.querySelector('img');
  if (!img) {
    return;
  }
  var src = img.src;
  if (!src || !src.startsWith('data:')) {
    return; // Normal URL  let the default <a> behaviour handle it.
  }
  e.preventDefault();
  fetch(src).then(function (res) {
    return res.blob();
  }).then(function (blob) {
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url;
    a.download = link.getAttribute('download') || 'generated-image.png';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(function () {
      URL.revokeObjectURL(url);
    }, 100);
  })["catch"](function (err) {
    console.error('Failed to download image:', err);
  });
});