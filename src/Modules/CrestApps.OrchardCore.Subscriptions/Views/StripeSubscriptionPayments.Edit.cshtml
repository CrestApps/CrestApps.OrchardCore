@using CrestApps.OrchardCore.Stripe.Core
@using CrestApps.OrchardCore.Subscriptions.Core
@using CrestApps.OrchardCore.Subscriptions.ViewModels

@model StripeViewModel

@if (!Model.IsLive && !string.IsNullOrEmpty(Model.PublishableKey))
{
    <div class="alert alert-info" role="alert">
        @T["Stripe is in test mode."]
    </div>
}
else if (string.IsNullOrEmpty(Model.PublishableKey))
{
    <div class="alert alert-warning" role="alert">
        @T["Stripe has not yet been configured. Please visit the configuration section and configure it."]
    </div>
}

<h5 class="card-title py-3">@T["Payment Method"]</h5>
<div id="card-errors" role="alert" class="alert alert-danger d-none"></div>

<!-- Additional input fields for billing details -->
<div class="mb-1">
    <label for="NameOnBankCard" class="visually-hidden"></label>
    <input id="NameOnBankCard" type="text" class="form-control" required placeholder="@T["Name as it appears on card"]">
</div>

<div id="card-element" class="form-control"></div>

<script asp-name="stripe"></script>
<script at="Foot" depends-on="stripe">
    document.addEventListener('DOMContentLoaded', () => {

        const errorElement = document.getElementById('card-errors');
        const showError = (message) => {
            errorElement.textContent = message;
            errorElement.classList.remove('d-none');
        };
        const clearError = () => {
            errorElement.textContent = '';
            errorElement.classList.add('d-none');
        };
        const getFilteredStyleObject = (element) => {
            const computedStyle = window.getComputedStyle(element);
            const styleObject = {};
            const propertiesToInclude = [
                'margin',
                'padding',
                'color',
                'font-family',
                'font-size',
                'line-height',
                'border-width',
                'border-style',
                'border-color'
            ];

            propertiesToInclude.forEach(property => {
                styleObject[property] = computedStyle.getPropertyValue(property);
            });

            return styleObject;
        }
        const applyStylesToStripeCard = (styles) => {
            return {
                base: {
                    color: styles.color || 'black', // default color if not specified
                    fontSize: styles['font-size'] || '16px', // default font size if not specified
                    fontFamily: styles['font-family'] || 'Arial, sans-serif', // default font family if not specified
                    lineHeight: styles['line-height'] || '1.4', // default line height if not specified
                    border: `${styles['border-width'] || '1px'} ${styles['border-style'] || 'solid'} ${styles['border-color'] || 'black'}` // default border if not specified
                },
            };
        }
        const payButton = document.getElementById('Subscription_Next_Button')

        const enableButton = (enable) => {
            if (enable) {
                payButton.disabled = false;
                payButton.classList.remove('disabled');
            } else {
                payButton.disabled = true;
                payButton.classList.remove('disabled');
            }
        };

        const stripe = Stripe('@Model.PublishableKey');
        const elements = stripe.elements();
        const nameOnBankCardElement = document.getElementById('NameOnBankCard');

        // Generate the filtered style object
        const filteredStyleObject = getFilteredStyleObject(nameOnBankCardElement);

        // Apply styles to Stripe card
        const cardStyles = applyStylesToStripeCard(filteredStyleObject);

        const cardElement = elements.create('card',
            {
                style: cardStyles
            });
        cardElement.mount('#card-element');
        cardElement.on('change', function (event) {
            clearError();
            enableButton(true);

            if (event.error) {
                showError(event.error.message);
            }
        });

        payButton.addEventListener('click', function (event) {
            event.preventDefault();
            enableButton(false);

            stripe.createPaymentMethod({
                type: 'card',
                card: cardElement,
                billing_details: {
                    name: nameOnBankCardElement.value,
                },
            }).then(function (result) {
                if (result.error) {
                    showError(result.error.message);
                } else {
                    // Send payment method ID to the server
                    fetch('@Url.RouteUrl(SubscriptionsConstants.RouteName.CreateSetupIntentEndpoint)', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            paymentMethodId: result.paymentMethod.id,
                            sessionId: '@Model.SessionId'
                        }),
                    }).then((response) => response.json())
                        .then((data) => {
                            if (data.error) {
                                showError(data.error);
                            } else {

                                stripe.confirmCardSetup(data.clientSecret)
                                    .then((result) => {
                                        if (result.error) {
                                            showError(result.error.message);
                                        } else {
                                            var paymentMethodId = result.setupIntent.payment_method;

                                            // Check if the initial payment amount is greater than $0.50
                                            if (data.processInitialPayment) {
                                                // Process initial payment
                                                fetch('@Url.RouteUrl(SubscriptionsConstants.RouteName.CreatePaymentIntentEndpoint)', {
                                                    method: 'POST',
                                                    headers: {
                                                        'Content-Type': 'application/json',
                                                    },
                                                    body: JSON.stringify({
                                                        customerId: data.customerId,
                                                        paymentMethodId: paymentMethodId,
                                                        sessionId: '@Model.SessionId',
                                                    }),
                                                }).then((response) => response.json())
                                                    .then((paymentData) => {
                                                        if (paymentData.error) {
                                                            showError(paymentData.error);
                                                        } else {
                                                            stripe.confirmCardPayment(paymentData.clientSecret)
                                                                .then((result) => {
                                                                    if (result.error) {
                                                                        showError(result.error.message);
                                                                    } else {
                                                                        // Handle successful payment and schedule the subscription
                                                                        createSubscription(data.customerId, paymentMethodId);
                                                                    }
                                                                });
                                                        }
                                                    });
                                            } else {
                                                // Skip initial payment and schedule the subscription
                                                createSubscription(data.customerId, paymentMethodId);
                                            }
                                        }
                                    });
                            }
                        });
                }
            });
        });

        const createSubscription = (customerId, paymentMethodId) => {
            fetch('@Url.RouteUrl(SubscriptionsConstants.RouteName.CreateSubscriptionEndpoint)', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    customerId: customerId,
                    paymentMethodId: paymentMethodId,
                    sessionId: '@Model.SessionId',
                }),
            }).then((response) => response.json())
                .then((subscriptionData) => {
                    if (subscriptionData.error) {
                        showError(subscriptionData.error);
                    } else {
                        const form = document.getElementById('subscription-form');

                        if (subscriptionData.status == 'requires_action') {
                            stripe.confirmCardPayment(subscriptionData.clientSecret)
                                .then(function (result) {
                                    if (result.error) {
                                        showError(result.error.message);
                                    } else {
                                        const submitEvent = new Event("submit", { bubbles: true, cancelable: true });
                                        form.dispatchEvent(submitEvent);
                                    }
                                });
                        } else {
                            const submitEvent = new Event("submit", { bubbles: true, cancelable: true });
                            form.dispatchEvent(submitEvent);
                        }
                    }
                });
        };
    });
</script>
