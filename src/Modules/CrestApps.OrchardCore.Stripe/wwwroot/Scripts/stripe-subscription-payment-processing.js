/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
stripePaymentProcessing = function () {
  var initialize = function initialize(options) {
    var defaultOptions = {
      processorKey: 'Stripe',
      cardElement: '#card-element'
    };

    // Extend the default options with the provided options.
    var config = _objectSpread(_objectSpread({}, defaultOptions), options);
    document.addEventListener('DOMContentLoaded', function () {
      var errorElement = document.getElementById('card-errors');
      var showError = function showError(message) {
        errorElement.textContent = message;
        errorElement.classList.remove('d-none');
      };
      var clearError = function clearError() {
        errorElement.textContent = '';
        errorElement.classList.add('d-none');
      };
      var getFilteredStyleObject = function getFilteredStyleObject(element) {
        if (!element) {
          return {};
        }
        var computedStyle = window.getComputedStyle(element);
        var styleObject = {};
        var propertiesToInclude = ['margin', 'padding', 'color', 'font-family', 'font-size', 'line-height', 'border-width', 'border-style', 'border-color'];
        propertiesToInclude.forEach(function (property) {
          styleObject[property] = computedStyle.getPropertyValue(property);
        });
        return styleObject;
      };
      var applyStylesToStripeCard = function applyStylesToStripeCard(styles) {
        return {
          base: {
            color: styles.color || 'black',
            // default color if not specified
            fontSize: styles['font-size'] || '16px',
            // default font size if not specified
            fontFamily: styles['font-family'] || 'Arial, sans-serif',
            // default font family if not specified
            lineHeight: styles['line-height'] || '1.4',
            // default line height if not specified
            border: "".concat(styles['border-width'] || '1px', " ").concat(styles['border-style'] || 'solid', " ").concat(styles['border-color'] || 'black') // default border if not specified
          }
        };
      };
      var stripe = Stripe(config.publishableKey);
      var elements = stripe.elements();

      // Generate the filtered style object
      var filteredStyleObject = getFilteredStyleObject(config.nameOnBankCardElement);

      // Apply styles to Stripe card
      var cardStyles = applyStylesToStripeCard(filteredStyleObject);
      var cardElement = elements.create('card', {
        style: cardStyles
      });
      cardElement.mount(config.cardElement);
      cardElement.on('change', function (event) {
        clearError();
        config.enablePayButtonButton(true);
        if (event.error) {
          showError(event.error.message);
        }
      });
      config.payButtonElement.addEventListener('click', function (event) {
        if (config.payButtonElement.getAttribute('data-method-name') != config.processorKey) {
          return;
        }
        event.preventDefault();
        if (config.nameOnBankCardElement && !config.nameOnBankCardElement.value) {
          showError(config.invalidNameErrorMessage);
          return;
        }
        config.enablePayButtonButton(false);
        stripe.createPaymentMethod({
          type: 'card',
          card: cardElement,
          billing_details: {
            name: config.nameOnBankCardElement.value || ''
          }
        }).then(function (result) {
          if (result.error) {
            showError(result.error.message);
          } else {
            // Send payment method ID to the server
            fetch(config.stepIntentEndpoint, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                paymentMethodId: result.paymentMethod.id,
                sessionId: config.sessionId
              })
            }).then(function (response) {
              return response.json();
            }).then(function (data) {
              if (data.error) {
                showError(data.error);
              } else {
                stripe.confirmCardSetup(data.clientSecret).then(function (result) {
                  if (result.error) {
                    showError(result.error.message);
                  } else {
                    var paymentMethodId = result.setupIntent.payment_method;
                    if (data.processInitialPayment) {
                      // Process initial payment
                      fetch(config.paymentIntentEndpoint, {
                        method: 'POST',
                        headers: {
                          'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                          customerId: data.customerId,
                          paymentMethodId: paymentMethodId,
                          sessionId: config.sessionId
                        })
                      }).then(function (response) {
                        return response.json();
                      }).then(function (paymentData) {
                        if (paymentData.error) {
                          showError(paymentData.error);
                        } else {
                          stripe.confirmCardPayment(paymentData.clientSecret).then(function (result) {
                            if (result.error) {
                              showError(result.error.message);
                            } else {
                              // Handle successful payment and schedule the subscription
                              createSubscription(data.customerId, paymentMethodId);
                            }
                          });
                        }
                      });
                    } else {
                      // Skip initial payment and schedule the subscription
                      createSubscription(data.customerId, paymentMethodId);
                    }
                  }
                });
              }
            });
          }
        });
      });
      var createSubscription = function createSubscription(customerId, paymentMethodId) {
        fetch(config.subscriptionEndpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            customerId: customerId,
            paymentMethodId: paymentMethodId,
            sessionId: config.sessionId
          })
        }).then(function (response) {
          return response.json();
        }).then(function (subscriptionData) {
          if (subscriptionData.error) {
            showError(subscriptionData.error);
          } else {
            var form = config.formElement;
            if (subscriptionData.status == 'requires_action') {
              stripe.confirmCardPayment(subscriptionData.clientSecret).then(function (result) {
                if (result.error) {
                  showError(result.error.message);
                } else {
                  var submitEvent = new Event("submit", {
                    bubbles: true,
                    cancelable: true
                  });
                  form.dispatchEvent(submitEvent);
                }
              });
            } else {
              var submitEvent = new Event("submit", {
                bubbles: true,
                cancelable: true
              });
              form.dispatchEvent(submitEvent);
            }
          }
        });
      };
    });
  };
  return {
    initialize: initialize
  };
}();