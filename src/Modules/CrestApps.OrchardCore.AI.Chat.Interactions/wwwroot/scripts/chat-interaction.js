/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
window.chatInteractionManager = function () {
  // Defaults (can be overridden by instanceConfig)
  var defaultConfig = {
    // UI defaults for generated media
    generatedImageAltText: 'Generated Image',
    generatedImageMaxWidth: 400,
    generatedChartMaxWidth: 900,
    downloadImageTitle: 'Download image',
    downloadChartTitle: 'Download chart as image',
    downloadChartButtonText: 'Download',
    messageTemplate: "\n            <div class=\"list-group\">\n                <div v-for=\"(message, index) in messages\" :key=\"index\" class=\"list-group-item\">\n                    <div class=\"d-flex align-items-center\">\n                        <div class=\"p-2\">\n                            <i :class=\"message.role === 'user' ? 'fa-solid fa-user fa-2xl text-primary' : 'fa fa-robot fa-2xl' + (message.isStreaming ? ' ai-streaming-icon' : ' ai-bot-icon')\"></i>\n                        </div>\n                        <div class=\"p-2 lh-base\">\n                            <h4 v-if=\"message.title\">{{ message.title }}</h4>\n                            <div v-html=\"message.htmlContent || message.content\"></div>\n                            <span class=\"message-buttons-container\" v-if=\"!isIndicator(message)\">\n                                <button class=\"btn btn-sm btn-outline-secondary button-message-toolbox\" @click=\"copyResponse(message.content)\" title=\"Click here to copy response to clipboard.\">\n                                    <i class=\"fa-solid fa-copy\"></i>\n                                </button>\n                            </span>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        ",
    indicatorTemplate: "<div class=\"spinner-grow spinner-grow-sm\" role=\"status\"><span class=\"visually-hidden\">Loading...</span></div>",
    // Localizable strings
    untitledText: 'Untitled',
    clearHistoryTitle: 'Clear History',
    clearHistoryMessage: 'Are you sure you want to clear the chat history? This action cannot be undone. Your documents, parameters, and tools will be preserved.',
    clearHistoryOkText: 'Yes',
    clearHistoryCancelText: 'Cancel'
  };
  var renderer = new marked.Renderer();

  // Modify the link rendering to open in a new tab
  renderer.link = function (data) {
    return "<a href=\"".concat(data.href, "\" target=\"_blank\" rel=\"noopener noreferrer\">").concat(data.text, "</a>");
  };

  // Custom image renderer for generated images with thumbnail styling and download button.
  // Handles both URL and data-URI sources (data URIs are converted to blobs for download).
  renderer.image = function (data) {
    var src = data.href;
    var alt = data.text || defaultConfig.generatedImageAltText;
    var maxWidth = defaultConfig.generatedImageMaxWidth;
    return "<div class=\"generated-image-container\">\n            <img src=\"".concat(src, "\" alt=\"").concat(alt, "\" class=\"img-thumbnail\" style=\"max-width: ").concat(maxWidth, "px; height: auto;\" />\n            <div class=\"mt-2\">\n                <a href=\"").concat(src, "\" target=\"_blank\" download=\"").concat(alt, "\" title=\"").concat(defaultConfig.downloadImageTitle, "\" class=\"btn btn-sm btn-outline-secondary ai-download-image\">\n                    <i class=\"fa-solid fa-download\"></i>\n                </a>\n            </div>\n        </div>");
  };

  // Chart counter for unique IDs
  var chartCounter = 0;

  // Collector for charts discovered during marked parsing.
  var _pendingCharts = [];
  function createChartHtml(chartId) {
    var chartMaxWidth = defaultConfig.generatedChartMaxWidth;
    return "<div class=\"chart-container\" style=\"position: relative; width: 100%; max-width: ".concat(chartMaxWidth, "px; margin: 0 auto; height: 480px;\">") + "<canvas id=\"".concat(chartId, "\" class=\"img-thumbnail\" width=\"").concat(chartMaxWidth, "\" height=\"480\" style=\"width: 100%; height: 480px;\"></canvas>") + "</div>" + "<div class=\"mt-2\">" + "<button type=\"button\" class=\"btn btn-sm btn-outline-secondary\" onclick=\"downloadChart('".concat(chartId, "')\" title=\"").concat(defaultConfig.downloadChartTitle, "\">") + "<i class=\"fa-solid fa-download\"></i> ".concat(defaultConfig.downloadChartButtonText) + "</button>" + "</div>";
  }

  // Register [chart:{...json...}] as a native marked block extension so the
  // markdown parser handles chart markers inline with surrounding text.
  marked.use({
    extensions: [{
      name: 'chart',
      level: 'block',
      start: function start(src) {
        var idx = src.indexOf('[chart:');
        return idx >= 0 ? idx : undefined;
      },
      tokenizer: function tokenizer(src) {
        var extracted = tryExtractChartMarker(src);
        if (!extracted || extracted.startIndex !== 0) {
          return undefined;
        }
        var chartId = "chat_chart_".concat(++chartCounter);
        return {
          type: 'chart',
          raw: src.substring(0, extracted.endIndex),
          chartId: chartId,
          json: extracted.json
        };
      },
      renderer: function renderer(token) {
        _pendingCharts.push({
          chartId: token.chartId,
          config: token.json
        });
        return createChartHtml(token.chartId);
      }
    }]
  });

  // Extract a [chart:{...json...}] marker. This avoids regex issues with nested brackets.
  function tryExtractChartMarker(text) {
    var token = '[chart:';
    var start = text.indexOf(token);
    if (start < 0) {
      return null;
    }

    // Find JSON object boundary by balancing braces
    var jsonStart = start + token.length;
    var i = jsonStart;
    while (i < text.length && (text[i] === ' ' || text[i] === '\n' || text[i] === '\r' || text[i] === '\t')) {
      i++;
    }
    if (i >= text.length || text[i] !== '{') {
      return null;
    }
    var depth = 0;
    var inString = false;
    var escape = false;
    for (; i < text.length; i++) {
      var ch = text[i];
      if (inString) {
        if (escape) {
          escape = false;
          continue;
        }
        if (ch === '\\') {
          escape = true;
          continue;
        }
        if (ch === '"') {
          inString = false;
        }
        continue;
      }
      if (ch === '"') {
        inString = true;
        continue;
      }
      if (ch === '{') {
        depth++;
      } else if (ch === '}') {
        depth--;
        if (depth === 0) {
          var jsonEnd = i;
          // Expect closing bracket after JSON
          var closeBracketIndex = text.indexOf(']', jsonEnd + 1);
          if (closeBracketIndex < 0) {
            return null;
          }
          var json = text.substring(jsonStart, jsonEnd + 1).trim();
          return {
            startIndex: start,
            endIndex: closeBracketIndex + 1,
            json: json
          };
        }
      }
    }
    return null;
  }
  function renderChartsInMessage(message) {
    if (!message || !message._pendingCharts || !message._pendingCharts.length) {
      return;
    }
    var _iterator = _createForOfIteratorHelper(message._pendingCharts),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var c = _step.value;
        var canvas = document.getElementById(c.chartId);
        if (!canvas) {
          continue;
        }
        if (typeof Chart === 'undefined') {
          console.error('Chart.js is not available on the page.');
          continue;
        }
        try {
          var _cfg$options;
          // Destroy existing chart instance if re-rendering
          if (canvas._chartInstance) {
            canvas._chartInstance.destroy();
          }
          var cfg = typeof c.config === 'string' ? JSON.parse(c.config) : c.config;
          (_cfg$options = cfg.options) !== null && _cfg$options !== void 0 ? _cfg$options : cfg.options = {};
          cfg.options.responsive = true;
          cfg.options.maintainAspectRatio = false;
          canvas._chartInstance = new Chart(canvas, cfg);
        } catch (e) {
          console.error('Error creating chart:', e);
        }
      }

      // Prevent re-render work
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    message._pendingCharts = [];
  }

  // Parse markdown content via marked (which natively handles [chart:...] markers
  // through the registered extension) and collect pending chart configs for later
  // Chart.js rendering.
  function parseMarkdownContent(content, message) {
    _pendingCharts = [];
    var html = marked.parse(content, {
      renderer: renderer
    });
    message._pendingCharts = _pendingCharts.length > 0 ? _toConsumableArray(_pendingCharts) : [];
    return html;
  }
  var initialize = function initialize(instanceConfig) {
    var config = Object.assign({}, defaultConfig, instanceConfig);
    // Keep defaultConfig in sync so renderers use overridden values
    defaultConfig = config;
    if (!config.signalRHubUrl) {
      console.error('The signalRHubUrl is required.');
      return;
    }
    if (!config.appElementSelector) {
      console.error('The appElementSelector is required.');
      return;
    }
    if (!config.chatContainerElementSelector) {
      console.error('The chatContainerElementSelector is required.');
      return;
    }
    if (!config.inputElementSelector) {
      console.error('The inputElementSelector is required.');
      return;
    }
    if (!config.sendButtonElementSelector) {
      console.error('The sendButtonElementSelector is required.');
      return;
    }
    var app = Vue.createApp({
      data: function data() {
        return {
          inputElement: null,
          buttonElement: null,
          chatContainer: null,
          placeholder: null,
          isInteractionStarted: false,
          isPlaceholderVisible: true,
          isStreaming: false,
          isNavigatingAway: false,
          autoScroll: true,
          stream: null,
          messages: [],
          prompt: '',
          initialFieldValues: new Map(),
          settingsDirty: false,
          saveSettingsTimeout: null
        };
      },
      methods: {
        handleBeforeUnload: function handleBeforeUnload() {
          this.isNavigatingAway = true;
        },
        startConnection: function startConnection() {
          var _this = this;
          return _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
            var _t;
            return _regenerator().w(function (_context) {
              while (1) switch (_context.p = _context.n) {
                case 0:
                  _this.connection = new signalR.HubConnectionBuilder().withUrl(config.signalRHubUrl).withAutomaticReconnect().build();

                  // Allow long-running operations (e.g., multi-step MCP tool calls)
                  // without the client disconnecting prematurely.
                  _this.connection.serverTimeoutInMilliseconds = 600000;
                  _this.connection.keepAliveIntervalInMilliseconds = 15000;
                  _this.connection.on("LoadInteraction", function (data) {
                    var _data$messages;
                    _this.initializeInteraction(data.itemId, true);
                    _this.messages = []; // Update the title field if it exists
                    var titleInput = document.querySelector('input[name="ChatInteraction.Title"]');
                    if (titleInput && data.title) {
                      titleInput.value = data.title;
                    }
                    ((_data$messages = data.messages) !== null && _data$messages !== void 0 ? _data$messages : []).forEach(function (msg) {
                      _this.addMessage(msg);
                      _this.$nextTick(function () {
                        renderChartsInMessage(msg);
                      });
                    });
                  });
                  _this.connection.on("SettingsSaved", function (itemId, title) {
                    // Update the history list item if it exists
                    // Use a more specific selector to only target history list items, not other elements like the Clear History button
                    var historyItem = document.querySelector(".chat-interaction-history-item[data-interaction-id=\"".concat(itemId, "\"]"));
                    if (historyItem) {
                      historyItem.textContent = title || config.untitledText;
                    }
                  });
                  _this.connection.on("ReceiveError", function (error) {
                    console.error("SignalR Error: ", error);
                  });
                  _this.connection.on("HistoryCleared", function (itemId) {
                    // Clear messages and show placeholder
                    _this.messages = [];
                    _this.showPlaceholder();

                    // Hide the clear history button since there's no history now
                    var clearHistoryBtn = document.getElementById('clearHistoryBtn');
                    if (clearHistoryBtn) {
                      clearHistoryBtn.classList.add('d-none');
                    }
                  });
                  _this.connection.onreconnecting(function () {
                    console.warn("SignalR: reconnecting...");
                  });
                  _this.connection.onreconnected(function () {
                    console.info("SignalR: reconnected.");
                  });
                  _this.connection.onclose(function (error) {
                    if (_this.isNavigatingAway) {
                      return;
                    }
                    if (error) {
                      console.warn("SignalR connection closed with error:", error.message || error);
                    }
                  });
                  _context.p = 1;
                  _context.n = 2;
                  return _this.connection.start();
                case 2:
                  _context.n = 4;
                  break;
                case 3:
                  _context.p = 3;
                  _t = _context.v;
                  console.error("SignalR Connection Error: ", _t);
                case 4:
                  return _context.a(2);
              }
            }, _callee, null, [[1, 3]]);
          }))();
        },
        addMessageInternal: function addMessageInternal(message) {
          var _this2 = this;
          this.fireEvent(new CustomEvent("addingChatInteractionMessage", {
            detail: {
              message: message
            }
          }));
          this.messages.push(message);
          this.$nextTick(function () {
            _this2.fireEvent(new CustomEvent("addedChatInteractionMessage", {
              detail: {
                message: message
              }
            }));
          });
        },
        addMessage: function addMessage(message) {
          var _this3 = this;
          if (message.content) {
            var processedContent = message.content.trim();
            if (message.references && _typeof(message.references) === "object" && Object.keys(message.references).length) {
              for (var _i = 0, _Object$entries = Object.entries(message.references); _i < _Object$entries.length; _i++) {
                var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                  key = _Object$entries$_i[0],
                  value = _Object$entries$_i[1];
                processedContent = processedContent.replaceAll(key, "<sup><strong>".concat(value.index, "</strong></sup>"));
              }
              processedContent = processedContent.replaceAll('</strong></sup><sup>', '</strong></sup><sup>,</sup><sup>');
              processedContent += '<br><br>';
              for (var _i2 = 0, _Object$values = Object.values(message.references); _i2 < _Object$values.length; _i2++) {
                var _value = _Object$values[_i2];
                processedContent += "**".concat(_value.index, "**. [").concat(_value.text, "](").concat(_value.link, ")<br>");
              }
            }
            message.content = processedContent;
            message.htmlContent = parseMarkdownContent(processedContent, message);
          }
          this.addMessageInternal(message);
          this.hidePlaceholder();
          this.$nextTick(function () {
            // Render any pending charts once the DOM is updated
            renderChartsInMessage(message);
            _this3.scrollToBottom();
          });
        },
        hidePlaceholder: function hidePlaceholder() {
          if (this.placeholder) {
            this.placeholder.classList.add('d-none');
          }
          this.isPlaceholderVisible = false;
        },
        showPlaceholder: function showPlaceholder() {
          if (this.placeholder) {
            this.placeholder.classList.remove('d-none');
          }
          this.isPlaceholderVisible = true;
        },
        fireEvent: function fireEvent(event) {
          document.dispatchEvent(event);
        },
        isIndicator: function isIndicator(message) {
          return message.role === 'indicator';
        },
        sendMessage: function sendMessage() {
          var trimmedPrompt = this.prompt.trim();
          if (!trimmedPrompt) {
            return;
          }
          this.addMessage({
            role: 'user',
            content: trimmedPrompt
          });

          // Show the clear history button since we now have prompts
          var clearHistoryBtn = document.getElementById('clearHistoryBtn');
          if (clearHistoryBtn) {
            clearHistoryBtn.classList.remove('d-none');
          }
          this.streamMessage(trimmedPrompt);
          this.inputElement.value = '';
          this.prompt = '';
        },
        streamMessage: function streamMessage(trimmedPrompt) {
          var _this4 = this;
          if (this.stream) {
            this.stream.dispose();
            this.stream = null;
          }
          this.streamingStarted();
          this.showTypingIndicator();
          this.autoScroll = true;
          var content = '';
          var references = {};
          var messageIndex = this.messages.length;
          var currentItemId = this.getItemId();
          this.stream = this.connection.stream("SendMessage", currentItemId, trimmedPrompt).subscribe({
            next: function next(chunk) {
              var message = _this4.messages[messageIndex];
              if (!message) {
                if (chunk.sessionId && !currentItemId) {
                  _this4.setItemId(chunk.sessionId);
                }
                _this4.hideTypingIndicator();
                messageIndex = _this4.messages.length;
                var newMessage = {
                  role: "assistant",
                  content: "",
                  htmlContent: "",
                  isStreaming: true
                };
                _this4.messages.push(newMessage);
                message = newMessage;
              }
              if (chunk.references && _typeof(chunk.references) === "object" && Object.keys(chunk.references).length) {
                for (var _i3 = 0, _Object$entries2 = Object.entries(chunk.references); _i3 < _Object$entries2.length; _i3++) {
                  var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2),
                    key = _Object$entries2$_i[0],
                    value = _Object$entries2$_i[1];
                  references[key] = value;
                }
              }
              if (chunk.content) {
                var processedContent = chunk.content;
                for (var _i4 = 0, _Object$entries3 = Object.entries(references); _i4 < _Object$entries3.length; _i4++) {
                  var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i4], 2),
                    _key = _Object$entries3$_i[0],
                    _value2 = _Object$entries3$_i[1];
                  processedContent = processedContent.replaceAll(_key, "<sup><strong>".concat(_value2.index, "</strong></sup>"));
                }
                content += processedContent.replaceAll('</strong></sup><sup>', '</strong></sup><sup>,</sup><sup>');
              }
              message.content = content;
              message.htmlContent = parseMarkdownContent(content, message);
              _this4.messages[messageIndex] = message;
              _this4.$nextTick(function () {
                renderChartsInMessage(message);
                _this4.scrollToBottom();
              });
            },
            complete: function complete() {
              var _this4$stream;
              _this4.processReferences(references, messageIndex);
              _this4.streamingFinished();
              var msg = _this4.messages[messageIndex];
              if (msg) {
                msg.isStreaming = false;
              }
              if (!msg || !msg.content) {
                // No content received at all.
                _this4.hideTypingIndicator();
              }
              (_this4$stream = _this4.stream) === null || _this4$stream === void 0 || _this4$stream.dispose();
              _this4.stream = null;
            },
            error: function error(err) {
              var _this4$stream2;
              _this4.processReferences(references, messageIndex);
              _this4.streamingFinished();
              var msg = _this4.messages[messageIndex];
              if (msg) {
                msg.isStreaming = false;
              }
              _this4.hideTypingIndicator();
              if (!_this4.isNavigatingAway) {
                _this4.addMessage(_this4.getServiceDownMessage());
              }
              (_this4$stream2 = _this4.stream) === null || _this4$stream2 === void 0 || _this4$stream2.dispose();
              _this4.stream = null;
              console.error("Stream error:", err);
            }
          });
        },
        getServiceDownMessage: function getServiceDownMessage() {
          return {
            role: "assistant",
            content: "Our service is currently unavailable. Please try again later. We apologize for the inconvenience.",
            htmlContent: ""
          };
        },
        processReferences: function processReferences(references, messageIndex) {
          if (Object.keys(references).length) {
            var _message$content;
            var message = this.messages[messageIndex];
            message.content = ((_message$content = message.content) === null || _message$content === void 0 ? void 0 : _message$content.trim()) + '<br><br>' || '';
            for (var _i5 = 0, _Object$values2 = Object.values(references); _i5 < _Object$values2.length; _i5++) {
              var value = _Object$values2[_i5];
              message.content += "**".concat(value.index, "**. [").concat(value.text, "](").concat(value.link, ")<br>");
            }
            message.htmlContent = parseMarkdownContent(message.content, message);
            this.messages[messageIndex] = message;
            this.scrollToBottom();
          }
        },
        streamingStarted: function streamingStarted() {
          var stopIcon = this.buttonElement.getAttribute('data-stop-icon');
          if (stopIcon) {
            this.buttonElement.innerHTML = stopIcon;
          }
        },
        streamingFinished: function streamingFinished() {
          var startIcon = this.buttonElement.getAttribute('data-start-icon');
          if (startIcon) {
            this.buttonElement.innerHTML = startIcon;
          }
        },
        showTypingIndicator: function showTypingIndicator() {
          this.addMessage({
            role: 'indicator',
            htmlContent: config.indicatorTemplate
          });
        },
        hideTypingIndicator: function hideTypingIndicator() {
          var originalLength = this.messages.length;
          this.messages = this.messages.filter(function (msg) {
            return msg.role !== 'indicator';
          });
          var removedCount = originalLength - this.messages.length;
          return removedCount;
        },
        scrollToBottom: function scrollToBottom() {
          var _this5 = this;
          if (!this.autoScroll) {
            return;
          }
          setTimeout(function () {
            _this5.chatContainer.scrollTop = _this5.chatContainer.scrollHeight - _this5.chatContainer.clientHeight;
          }, 50);
        },
        handleUserInput: function handleUserInput(event) {
          this.prompt = event.target.value;
        },
        getItemId: function getItemId() {
          return this.inputElement.getAttribute('data-interaction-id');
        },
        setItemId: function setItemId(itemId) {
          this.inputElement.setAttribute('data-interaction-id', itemId || '');
        },
        resetInteraction: function resetInteraction() {
          this.setItemId('');
          this.isInteractionStarted = false;
          this.messages = [];
          this.showPlaceholder();
        },
        initializeApp: function initializeApp() {
          var _this6 = this;
          this.inputElement = document.querySelector(config.inputElementSelector);
          this.buttonElement = document.querySelector(config.sendButtonElementSelector);
          this.chatContainer = document.querySelector(config.chatContainerElementSelector);
          this.placeholder = document.querySelector(config.placeholderElementSelector);

          // Pause auto-scroll when the user manually scrolls up during streaming.
          this.chatContainer.addEventListener('scroll', function () {
            if (!_this6.stream) {
              return;
            }
            var threshold = 30;
            var atBottom = _this6.chatContainer.scrollHeight - _this6.chatContainer.clientHeight - _this6.chatContainer.scrollTop <= threshold;
            _this6.autoScroll = atBottom;
          });
          this.inputElement.addEventListener('keyup', function (event) {
            if (_this6.stream != null) {
              return;
            }
            if (event.key === "Enter" && !event.shiftKey) {
              _this6.buttonElement.click();
            }
          });
          this.inputElement.addEventListener('input', function (e) {
            _this6.handleUserInput(e);
            if (e.target.value.trim()) {
              _this6.buttonElement.removeAttribute('disabled');
            } else {
              _this6.buttonElement.setAttribute('disabled', true);
            }
          });
          this.inputElement.addEventListener('paste', function (e) {
            // Use setTimeout to allow the paste to complete before checking the value
            setTimeout(function () {
              _this6.prompt = _this6.inputElement.value;
              if (_this6.inputElement.value.trim()) {
                _this6.buttonElement.removeAttribute('disabled');
              } else {
                _this6.buttonElement.setAttribute('disabled', true);
              }
            }, 0);
          });
          this.buttonElement.addEventListener('click', function () {
            if (_this6.stream != null) {
              _this6.stream.dispose();
              _this6.stream = null;
              _this6.streamingFinished();
              _this6.hideTypingIndicator();

              // Clean up: remove empty assistant message or stop streaming animation.
              if (_this6.messages.length > 0) {
                var lastMsg = _this6.messages[_this6.messages.length - 1];
                if (lastMsg.role === 'assistant' && !lastMsg.content) {
                  _this6.messages.pop();
                } else if (lastMsg.isStreaming) {
                  lastMsg.isStreaming = false;
                }
              }
              return;
            }
            _this6.sendMessage();
          });
          var chatInteractionItems = document.getElementsByClassName('chat-interaction-history-item');
          for (var i = 0; i < chatInteractionItems.length; i++) {
            chatInteractionItems[i].addEventListener('click', function (e) {
              e.preventDefault();
              var itemId = e.target.getAttribute('data-interaction-id');
              if (!itemId) {
                console.error('An element with the class chat-interaction-history-item with no data-interaction-id set.');
                return;
              }
              _this6.loadInteraction(itemId);
            });
          }
          for (var _i6 = 0; _i6 < config.messages.length; _i6++) {
            this.addMessage(config.messages[_i6]);
          }

          // Add event listeners for all settings fields with "ChatInteraction." prefix
          // Exclude tool and MCP connection inputs (they have special handling with debouncing)
          var settingsInputs = document.querySelectorAll('input[name^="ChatInteraction."]:not([name*=".Tools["]):not([name*=".Connections["]), ' + 'select[name^="ChatInteraction."]:not([name*=".Tools["]):not([name*=".Connections["]), ' + 'textarea[name^="ChatInteraction."]:not([name*=".Tools["]):not([name*=".Connections["])');
          settingsInputs.forEach(function (input) {
            var isCheckbox = input.type === 'checkbox';
            var isSelect = input.tagName === 'SELECT';

            // Checkboxes & selects save immediately
            if (isCheckbox || isSelect) {
              input.addEventListener('change', function () {
                _this6.settingsDirty = true;
                _this6.debouncedSaveSettings();
              });
              return;
            }

            // Text / textarea / number inputs → save on blur if changed
            input.addEventListener('focus', function () {
              _this6.initialFieldValues.set(input, input.value);
            });
            input.addEventListener('blur', function () {
              var initialValue = _this6.initialFieldValues.get(input);
              var hasChanged = initialValue !== undefined && input.value !== initialValue;
              if (hasChanged) {
                _this6.settingsDirty = true;
                _this6.debouncedSaveSettings();
              }
              _this6.initialFieldValues["delete"](input);
            });
          });

          // Add event listeners for tool checkboxes with debouncing (850ms)
          var toolCheckboxes = document.querySelectorAll('input[type="checkbox"][name$="].IsSelected"][name^="ChatInteraction.Tools["]');
          toolCheckboxes.forEach(function (checkbox) {
            checkbox.addEventListener('change', function () {
              _this6.settingsDirty = true;
              _this6.debouncedSaveSettings();
            });
          });

          // Add event listeners for "Select All" group toggle checkboxes with debouncing (850ms)
          var groupToggleCheckboxes = document.querySelectorAll('input[type="checkbox"].group-toggle');
          groupToggleCheckboxes.forEach(function (toggle) {
            toggle.addEventListener('change', function () {
              _this6.settingsDirty = true;
              _this6.debouncedSaveSettings();
            });
          });

          // Add event listeners for MCP connection checkboxes with debouncing (850ms)
          var mcpCheckboxes = document.querySelectorAll('input[type="checkbox"][name$="].IsSelected"][name^="ChatInteraction.Connections["]');
          mcpCheckboxes.forEach(function (checkbox) {
            checkbox.addEventListener('change', function () {
              _this6.settingsDirty = true;
              _this6.debouncedSaveSettings();
            });
          });

          // Add event listener for clear history button
          var clearHistoryBtn = document.getElementById('clearHistoryBtn');
          if (clearHistoryBtn) {
            clearHistoryBtn.addEventListener('click', function () {
              var itemId = clearHistoryBtn.getAttribute('data-interaction-id');
              if (itemId) {
                _this6.clearHistory(itemId);
              }
            });
          }
        },
        loadInteraction: function loadInteraction(itemId) {
          this.connection.invoke("LoadInteraction", itemId)["catch"](function (err) {
            return console.error(err);
          });
        },
        clearHistory: function clearHistory(itemId) {
          var self = this;
          confirmDialog({
            title: config.clearHistoryTitle,
            message: config.clearHistoryMessage,
            okText: config.clearHistoryOkText,
            cancelText: config.clearHistoryCancelText,
            callback: function callback(confirmed) {
              if (confirmed) {
                // Cancel any active stream before clearing history.
                if (self.stream) {
                  self.stream.dispose();
                  self.stream = null;
                  self.hideTypingIndicator();
                  self.streamingFinished();
                }
                self.connection.invoke("ClearHistory", itemId)["catch"](function (err) {
                  return console.error('Error clearing history:', err);
                });
              }
            }
          });
        },
        debouncedSaveSettings: function debouncedSaveSettings() {
          var _this7 = this;
          // Clear any existing timeout to reset the debounce timer
          if (this.saveSettingsTimeout) {
            clearTimeout(this.saveSettingsTimeout);
          }
          // Set a new timeout to save after 850ms of no changes
          this.saveSettingsTimeout = setTimeout(function () {
            if (_this7.settingsDirty) {
              _this7.saveSettings();
              _this7.settingsDirty = false;
            }
            _this7.saveSettingsTimeout = null;
          }, 850);
        },
        getSelectedToolNames: function getSelectedToolNames() {
          // Find all checked tool checkboxes and get the corresponding ItemId values
          var toolNames = [];
          var toolCheckboxes = document.querySelectorAll('input[type="checkbox"][name$="].IsSelected"][name^="ChatInteraction.Tools["]:checked');
          toolCheckboxes.forEach(function (checkbox) {
            // Extract the base name pattern to find the corresponding hidden ItemId input
            // Checkbox name: ChatInteraction.Tools[Content Definitions][0].IsSelected
            // Hidden name:   ChatInteraction.Tools[Content Definitions][0].ItemId
            var baseName = checkbox.name.replace('.IsSelected', '.ItemId');
            var hiddenInput = document.querySelector("input[type=\"hidden\"][name=\"".concat(baseName, "\"]"));
            if (hiddenInput && hiddenInput.value) {
              toolNames.push(hiddenInput.value);
            }
          });
          return toolNames;
        },
        getSelectedMcpConnectionIds: function getSelectedMcpConnectionIds() {
          var connectionIds = [];
          var mcpCheckboxes = document.querySelectorAll('input[type="checkbox"][name$="].IsSelected"][name^="ChatInteraction.Connections["]:checked');
          mcpCheckboxes.forEach(function (checkbox) {
            var baseName = checkbox.name.replace('.IsSelected', '.ItemId');
            var hiddenInput = document.querySelector("input[type=\"hidden\"][name=\"".concat(baseName, "\"]"));
            if (hiddenInput && hiddenInput.value) {
              connectionIds.push(hiddenInput.value);
            }
          });
          return connectionIds;
        },
        saveSettings: function saveSettings() {
          var itemId = this.getItemId();
          if (!itemId) {
            return;
          }
          var settings = {};

          // Collect all form inputs with the "ChatInteraction." prefix generically.
          // This avoids coupling the JS to specific field names — new fields added by
          // any module are automatically included.
          var inputs = document.querySelectorAll('input[name^="ChatInteraction."]:not([name*=".Tools["]):not([name*=".Connections["]), ' + 'select[name^="ChatInteraction."]:not([name*=".Tools["]):not([name*=".Connections["]), ' + 'textarea[name^="ChatInteraction."]:not([name*=".Tools["]):not([name*=".Connections["])');
          inputs.forEach(function (input) {
            // Extract field name: "ChatInteraction.Title" → "title"
            var fieldName = input.name.replace('ChatInteraction.', '');
            var key = fieldName.charAt(0).toLowerCase() + fieldName.slice(1);
            if (input.type === 'checkbox') {
              settings[key] = input.checked;
            } else if (input.type === 'number') {
              settings[key] = input.value ? parseFloat(input.value) : null;
            } else {
              settings[key] = input.value || null;
            }
          });

          // Add tool and MCP connection collections (special handling).
          settings.toolNames = this.getSelectedToolNames();
          settings.mcpConnectionIds = this.getSelectedMcpConnectionIds();
          this.connection.invoke("SaveSettings", itemId, settings)["catch"](function (err) {
            return console.error('Error saving settings:', err);
          });
        },
        initializeInteraction: function initializeInteraction(itemId, force) {
          if (this.isInteractionStarted && !force) {
            return;
          }
          this.fireEvent(new CustomEvent("initializingChatInteraction", {
            detail: {
              itemId: itemId
            }
          }));
          this.setItemId(itemId);
          this.isInteractionStarted = true;
        },
        copyResponse: function copyResponse(message) {
          navigator.clipboard.writeText(message);
        }
      },
      mounted: function mounted() {
        var _this8 = this;
        _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
          return _regenerator().w(function (_context2) {
            while (1) switch (_context2.n) {
              case 0:
                _context2.n = 1;
                return _this8.startConnection();
              case 1:
                _this8.initializeApp();
              case 2:
                return _context2.a(2);
            }
          }, _callee2);
        }))();
        window.addEventListener('beforeunload', this.handleBeforeUnload);
      },
      beforeUnmount: function beforeUnmount() {
        window.removeEventListener('beforeunload', this.handleBeforeUnload);
        if (this.stream) {
          this.stream.dispose();
          this.stream = null;
        }
        if (this.connection) {
          this.connection.stop();
        }
      },
      template: config.messageTemplate
    }).mount(config.appElementSelector);
    return app;
  };
  return {
    initialize: initialize
  };
}();

// Global function for downloading charts as images
window.downloadChart = function (chartId) {
  var canvas = document.getElementById(chartId);
  if (!canvas) {
    console.error('Chart canvas not found:', chartId);
    return;
  }

  // Create a temporary link element
  var link = document.createElement('a');
  link.download = 'chart-' + chartId + '.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
};

// Intercept download clicks for data-URI images and convert to blob downloads.
document.addEventListener('click', function (e) {
  var link = e.target.closest('.ai-download-image');
  if (!link) {
    return;
  }
  var container = link.closest('.generated-image-container');
  var img = container === null || container === void 0 ? void 0 : container.querySelector('img');
  if (!img) {
    return;
  }
  var src = img.src;
  if (!src || !src.startsWith('data:')) {
    return; // Normal URL – let the default <a> behaviour handle it.
  }
  e.preventDefault();
  fetch(src).then(function (res) {
    return res.blob();
  }).then(function (blob) {
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url;
    a.download = link.getAttribute('download') || 'generated-image.png';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(function () {
      URL.revokeObjectURL(url);
    }, 100);
  })["catch"](function (err) {
    console.error('Failed to download image:', err);
  });
});