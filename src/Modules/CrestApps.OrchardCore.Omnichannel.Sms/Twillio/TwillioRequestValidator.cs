using System.Collections.Specialized;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;

namespace CrestApps.OrchardCore.Omnichannel.Sms.Twillio;

internal sealed class TwillioRequestValidator
{
    private readonly byte[] _secret;

    /// <summary>
    /// Create a new RequestValidator
    /// </summary>
    /// <param name="secret">Signing secret</param>
    public TwillioRequestValidator(string secret)
    {
        ArgumentException.ThrowIfNullOrEmpty(secret);

        _secret = Encoding.UTF8.GetBytes(secret);
    }

    /// <summary>
    /// Validate against a request.
    /// The validate function is provided to validate incoming webhook requests from Twilio.
    /// It does this by comparing the expected signature passed in with a signature it generates itself.
    /// The signature is generated by creating an HMAC-SHA1 hash using the signing secret as the key,
    /// and the full URL (including query string parameters and bodySHA256) as the message.
    /// This validator is cloned from https://github.com/twilio/twilio-csharp/blob/main/src/Twilio/Security/RequestValidator.cs
    /// </summary>
    /// <param name="url">Request URL - This URL should include all query parameters and bodySHA256</param>
    /// <param name="parameters">Request parameters. This includes any body that is part of the request.</param>
    /// <param name="expected">Every Twilio Request has an x-twilio-signature associated with it. This is the expected twilio signature against which the generated signature is compared with.</param>
    /// <returns>true if the signature matches the result; false otherwise</returns>
    public bool Validate(string url, NameValueCollection parameters, string expected)
    {
        return Validate(url, ToDictionary(parameters), expected);
    }

    /// <summary>
    /// Validate against a request.
    /// The validate function is provided to validate incoming webhook requests from Twilio.
    /// It does this by comparing the expected signature passed in with a signature it generates itself.
    /// The signature is generated by creating an HMAC-SHA1 hash using the signing secret as the key,
    /// and the full URL (including query string parameters and bodySHA256) as the message.
    /// </summary>
    /// <param name="url">Request URL - This URL should include all query parameters and bodySHA256</param>
    /// <param name="parameters">Request parameters. This includes any body that is part of the request.</param>
    /// <param name="expected">Every Twilio Request has an x-twilio-signature associated with it. This is the expected twilio signature against which the generated signature is compared with.</param>
    /// <returns>true if the signature matches the result; false otherwise</returns>
    public bool Validate(string url, IDictionary<string, string> parameters, string expected)
    {
        ArgumentException.ThrowIfNullOrEmpty(url);
        ArgumentException.ThrowIfNullOrEmpty(expected);

#pragma warning disable CA5350 // Do Not Use Weak Cryptographic Algorithms
        using var hmac = new HMACSHA1(_secret);
#pragma warning restore CA5350 // Do Not Use Weak Cryptographic Algorithms

        if (parameters == null || parameters.Count == 0)
        {
            var sig = GetValidationSignature(url, hmac.ComputeHash);
            if (SecureCompare(sig, expected))
            {
                return true;
            }

            // check signature of url with and without port, since sig generation on back end is inconsistent
            // If either url produces a valid signature, we accept the request as valid
            url = GetUriVariation(url);
            sig = GetValidationSignature(url, hmac.ComputeHash);
            if (SecureCompare(sig, expected))
            {
                return true;
            }

            return false;
        }

        var parameterStringBuilder = GetJoinedParametersStringBuilder(parameters);
        parameterStringBuilder.Insert(0, url);
        var signature = GetValidationSignature(parameterStringBuilder.ToString(), hmac.ComputeHash);
        if (SecureCompare(signature, expected))
        {
            return true;
        }

        parameterStringBuilder.Remove(0, url.Length);

        // check signature of url with and without port, since sig generation on back end is inconsistent
        // If either url produces a valid signature, we accept the request as valid
        url = GetUriVariation(url);

        parameterStringBuilder.Insert(0, url);

        signature = GetValidationSignature(parameterStringBuilder.ToString(), hmac.ComputeHash);

        if (SecureCompare(signature, expected))
        {
            return true;
        }

        return false;
    }

    public bool Validate(string url, string body, string expected)
    {
        ArgumentException.ThrowIfNullOrEmpty(url);
        ArgumentException.ThrowIfNullOrEmpty(body);
        ArgumentException.ThrowIfNullOrEmpty(expected);

        var paramString = new Uri(url, UriKind.Absolute).Query.TrimStart('?');
        var bodyHash = paramString.Split('&')
            .Select(param => param.Split('='))
            .Where(split => split[0] == "bodySHA256")
            .Select(split => Uri.UnescapeDataString(split[1]))
            .FirstOrDefault() ?? "";

        return Validate(url, (IDictionary<string, string>)null, expected) && ValidateBody(body, bodyHash);
    }

    /// <summary>
    /// Validate the body of a request.
    /// The validateBody function is provided to validate the body of incoming webhook requests from Twilio
    /// It does this by creating a SHA256 hash of the body and comparing it to the expected hash.
    /// </summary>
    /// <param name="rawBody">Raw body of the request</param>
    /// <param name="expected">The expected SHA256 hash of the body</param>
    public bool ValidateBody(string rawBody, string expected)
    {
#pragma warning disable CA5350 // Do Not Use Weak Cryptographic Algorithms
        using var hmac = new HMACSHA1(_secret);
#pragma warning restore CA5350 // Do Not Use Weak Cryptographic Algorithms

        var signature = hmac.ComputeHash(Encoding.UTF8.GetBytes(rawBody));

        return SecureCompare(Convert.ToHexStringLower(signature), expected);
    }

    private static Dictionary<string, string> ToDictionary(NameValueCollection col)
    {
        var dict = new Dictionary<string, string>();

        foreach (var k in col.AllKeys)
        {
            dict.Add(k, col[k]);
        }

        return dict;
    }

    private static StringBuilder GetJoinedParametersStringBuilder(IDictionary<string, string> parameters)
    {
        var keys = parameters.Keys.ToArray();

        Array.Sort(keys, StringComparer.Ordinal);

        var b = new StringBuilder();
        foreach (var key in keys)
        {
            b.Append(key).Append(parameters[key] ?? "");
        }

        return b;
    }

    private static string GetValidationSignature(string urlWithParameters, Func<byte[], byte[]> computeHash)
    {
        var hash = computeHash(Encoding.UTF8.GetBytes(urlWithParameters));

        return Convert.ToBase64String(hash);
    }

    [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
    private static bool SecureCompare(string a, string b)
    {
        if (a == null || b == null)
        {
            return false;
        }

        var n = a.Length;
        if (n != b.Length)
        {
            return false;
        }

        var mismatch = 0;
        for (var i = 0; i < n; i++)
        {
            mismatch |= a[i] ^ b[i];
        }

        return mismatch == 0;
    }

    /// <summary>
    /// Returns URL without port if given URL has port, returns URL with port if given URL has no port
    /// </summary>
    /// <param name="url"></param>
    /// <returns></returns>
    private static string GetUriVariation(string url)
    {
        var uri = new Uri(url);
        var uriBuilder = new UriBuilder(uri);
        var port = uri.GetComponents(UriComponents.Port, UriFormat.UriEscaped);
        // if port already removed
        if (port == "")
        {
            return SetPort(url, uriBuilder, uriBuilder.Port);
        }

        return SetPort(url, uriBuilder, -1);
    }

    private static string SetPort(string url, UriBuilder uri, int newPort)
    {
        if (newPort == -1)
        {
            uri.Port = newPort;
        }
        else if (newPort != 443 && newPort != 80)
        {
            uri.Port = newPort;
        }
        else
        {
            uri.Port = uri.Scheme == "https" ? 443 : 80;
        }

        var uriStringBuilder = new StringBuilder(uri.ToString());

        var host = PreserveCase(url, uri.Host);
        uriStringBuilder.Replace(uri.Host, host);

        var scheme = PreserveCase(url, uri.Scheme);
        uriStringBuilder.Replace(uri.Scheme, scheme);

        return uriStringBuilder.ToString();
    }

    private static string PreserveCase(string url, string replacementString)
    {
        var startIndex = url.IndexOf(replacementString, StringComparison.OrdinalIgnoreCase);

        return url.Substring(startIndex, replacementString.Length);
    }
}
